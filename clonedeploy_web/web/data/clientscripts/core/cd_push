#!/bin/bash

. /bin/cd_global_functions

function process_hard_drives()
{
get_hard_drives
echo
sleep 2

imaged_schema_drives=""
current_hd_number=0
for hd in $hard_drives; do
	current_hd_number=$(( $current_hd_number + 1 ))
	
	drive=$(echo $hd | cut -d "/" -f 3)
	lbs=$(cat /sys/block/$drive/queue/logical_block_size)
	dsize=$(cat /sys/block/$drive/size)
	newHDSize=`expr $lbs '*' $dsize`
	log "profileId=$profile_id&clientHdNumber=$current_hd_number&newHdSize=$newHDSize&schemaHds=$imaged_schema_drives"
	hd_schema=$($curlAuth --data "profileId=$profile_id&clientHdNumber=$current_hd_number&newHdSize=$newHDSize&schemaHds=$(remove_whitespace $imaged_schema_drives)" "${web}CheckHdRequirements" $curlEnd)
	log "$hd_schema"
	
	image_hd_to_use=$(( $(parse_json "$hd_schema" .SchemaHdNumber) + 1 ))
	image_path=/storage/images/$image_name/hd$image_hd_to_use
	
	create_partition_layout
	
	process_partitions
	
	update_grub
	
	if [ "$(parse_json "$hd_schema" .PartitionType)" = "gpt" ]; then
		log " ** Restoring GUID ** "
		hdgptGUID=`curl -sSkL "${web}GetHdParameter?imgName=$imgName&paramName=HDguid&hdToGet=$hdToGet&partNumber=0" --connect-timeout 10 --stderr -`
		log " ...... hd $hd hdgptGUID: $hdgptGUID "
		sgdisk $hd -U$hdgptGUID &>> /tmp/clientlog.log
	
	fi
	
	imaged_schema_drives="$imaged_schema_drives $(parse_json "$hd_schema" .SchemaHdNumber) "

done
}


function process_lvm()
{
  local array_index=-1
  local volume_group="$(parse_json "$current_partition" .VolumeGroup.Name)"
  while [  "$(( $array_index + 1 ))" -lt "$(parse_json "$current_partition" .VolumeGroup.LogicalVolumeCount)" ]; do
  array_index=$(( $array_index + 1))
	  clear_and_move_down
    current_logical_volume="$(parse_json "$current_partition" .VolumeGroup.LogicalVolumes[$array_index])"
	unescaped_lv_name=$(echo $(parse_json "$current_logical_volume" .Name) | sed 's/--/-/g')
	
	if [ "$(parse_json "$current_logical_volume" .FileSystem)" = "swap" ]; then
			log "Creating Swap On $volume_group-$unescaped_lv_name"
			log "$(parse_json "$current_logical_volume" .Uuid)"
			mkswap /dev/mapper/$volume_group-$unescaped_lv_name -U $(parse_json "$current_logical_volume" .Uuid) &>> /tmp/makeswap
			cat /tmp/makeswap >>/tmp/clientlog.log
			mkswapResult=$(cat /tmp/makeswap | grep "parsing UUID failed")
			if [ "$?" = "0" ]; then
				log " ...... Swap Creation Failed, Creating Swap With New UUID "
				mkswap /dev/mapper/$volume_group-$unescaped_lv_name &>> /tmp/clientlog.log
			fi
			continue
	fi
				
		download_image "$current_logical_volume" "$volume_group-$unescaped_lv_name"
		
		

	
		clear
	done
}

function process_partitions()
{	
	
	
	local array_index=-1
	while [  "$(( $array_index + 1 ))" -lt "$(parse_json "$hd_schema" .PhysicalPartitionCount)" ]; do
	array_index=$(( $array_index + 1))
	  clear_and_move_down
	  current_partition="$(parse_json "$hd_schema" .PhysicalPartitions[$array_index])"
		log "$current_partition"
		
		if [ -n "$(parse_json "$current_partition" .VolumeGroup)" ] && [ "$(parse_json "$current_partition" .VolumeGroup)" != "null" ]; then
			process_lvm
			continue
		fi
		
		if [ "$(parse_json "$current_partition" .FileSystem)" = "swap" ]; then
			log "Creating Swap On $hd$(parse_json "$current_partition" .Number)"
			log "$(parse_json "$current_partition" .Uuid)"
			mkswap $hd$(parse_json "$current_partition" .Number) -U $(parse_json "$current_partition" .Uuid) &>> /tmp/clientlog.log	
			continue
		fi
			
		download_image "$current_partition" part
		
		pMBSize=$(parted -s $hd unit MB print all | grep " $(parse_json "$current_partition" .Number) " -m 1 | awk -F' ' '{print $4}' | sed 's/MB//g')
		if [ "$pMBSize" -gt "2000" ]; then
			expand_volume $hd$(parse_json "$current_partition" .Number) $(parse_json "$current_partition" .FileSystem)
		fi
		
		
		
	
	if [ "$(parse_json "$hd_schema" .PartitionType)" = "gpt" ]; then
		log " ** Restoring GUID ** "
	

			log " ...... part $part gptGUID: $gptGUID "
			sgdisk $hd -u$(parse_json "$current_partition" .Number):$(parse_json "$current_partition" .Guid) &>> /tmp/clientlog.log

	fi
		
		if [ "$(parse_json "$hd_schema" .Boot)" = "$(parse_json "$current_partition" .Number)" ] && [ "$(parse_json "$current_partition" .FileSystem)" = "ntfs" ]; then
			fix_ntfs_boot $hd$(parse_json "$current_partition" .Number)
		fi
		
		if [ "$(parse_json "$current_partition" .FileSystem)" = "ntfs" ] && [ "$skip_fix_bcd" != "true" ]; then
			update_bcd
		fi
		change_computer_name
	
		
	done
	
	

}

function download_image()
{
  local current_object="$1"
  local file_name_prefix="$2"
  local destination=""
  
  
  if [ "$file_name_prefix" != "part" ]; then
	destination="/dev/mapper/$file_name_prefix"
  else
    destination=$hd$(parse_json "$current_object" .Number)
	file_name_prefix=part"$(parse_json "$current_object" .Number)"
  fi
  
  
   log " ** Starting Image Download For $destination ** " "display" 
	if [ -n "$computer_id" ]; then    
	  null=$($curlAuth --data "computerId=$computer_id&partition=$destination" "${web}UpdateProgressPartition" $curlEnd)
    fi
    sleep 7
    echo
	
  if [ "$(parse_json "$current_object" .Compression)" = "gz" ]; then
		partCompAlg="/usr/bin/gzip -c -d"
			partCompExt="gz"
		
		elif [ "$(parse_json "$current_object" .Compression)" = "lz4" ]; then
			partCompAlg="lz4 -d"
			partCompExt="lz4"
		else
		error "Could Not Determine Compression Algorithm For Partition"
		fi
		

		


			touch /tmp/clone.progress
			
            if [ "$multicast" = "true" ]; then
			  	log "cd_reporter $computer_id partclone & udp-receiver --portbase $portBase --no-progress --mcast-rdv-address $serverIP $clientReceiverArgs | partclone.$(parse_json "$current_partition" .PartcloneFileSystem) -B -r -o $hd$(parse_json "$current_partition" .Number)"
				cd_reporter $computer_id partclone & udp-receiver --portbase $portBase --no-progress --mcast-rdv-address $serverIP $clientReceiverArgs | partclone.$(parse_json "$current_partition" .PartcloneFileSystem) -B -r -o $hd$(parse_json "$current_partition" .Number)
			else
				log "cd_reporter $computer_id partclone & $partCompAlg $image_path/$file_name_prefix.$(parse_json "$current_object" .PartcloneFileSystem).$partCompExt | partclone.$(parse_json "$current_object" .PartcloneFileSystem) -B -r -o $destination"
				cd_reporter $computer_id partclone & $partCompAlg $image_path/$file_name_prefix.$(parse_json "$current_object" .PartcloneFileSystem).$partCompExt | partclone.$(parse_json "$current_object" .PartcloneFileSystem) -B -r -o $destination
		    fi
			
		

		rm /tmp/clone.progress
		cat /var/log/partclone.log >> /tmp/clientlog.log

}

function restore_mbr_gpt()
{
	log " ** Restoring MBR / GPT On $hd ** " "display"


	dd if=$image_path/table of=$hd &>>/tmp/clientlog.log				
		
	
	#Sometimes restoring results in damaged GPT.
	isDamaged=`gdisk -l $hd <<< "2" 2>>/tmp/clientlog.log | grep 'GPT:' | awk '{$1=""; print $0}' | sed 's/^ //'`
	if [ "$isDamaged" = "damaged" ]; then
		gdisk $hd << eof >> /tmp/clientlog.log
2
w
y
eof

	fi
	
	hybridCheck=`gdisk -l $hd <<< "q" 2>> /tmp/clientlog.log| grep 'MBR:' | awk '{$1=""; print $0}' | sed 's/^ //'`
	if [ "$hybridCheck" = "hybrid" ]; then
		usingHybrid="true"
	fi
	
	log " ...... Complete" "display"
	echo 
	partprobe &>/dev/null
	sleep 2
}

function update_grub()
{

	log " ** Checking If Grub Is Required ** "
	dd if=$hd of=/tmp/grubcheck bs=512 count=1 2> /dev/null
	strings /tmp/grubcheck | grep -i "grub"
	if [ "$?" = "0" ]; then
		log " ...... Grub Is Required, Searching For Boot Files "
		if [ -n "$grubRoot" ]; then
			log " ...... Grub Root Overridden By User $grubRoot "
			grubHD=$(echo $grubRoot | cut -d"," -f1)
			grubHD="$grubHD)"
		else
			grub --batch <<eof>> /tmp/grubroot
find /grub/menu.lst
find /boot/grub/menu.lst
eof
			cat /tmp/grubroot >>/tmp/clientlog.log
			grubHdPass=$(( $current_hd_number - 1 ))
			grubRoot=$(cat /tmp/grubroot | grep -i "hd$grubHdPass")
			grubHD=$(echo $grubRoot | cut -d"," -f1)
			grubHD="$grubHD)"
		fi
			log "grubHdPass: $grubHdPass grubRoot: $grubRoot grubHD: $grubHD current_hd_number: $current_hd_number"
		
		if [ -n "$grubRoot" ]; then
			log " ...... Found Legacy Grub On $grubRoot "
			log " ...... Restoring Grub Legacy "
			grub --batch <<eof>> /tmp/clientlog.log
root $grubRoot
setup $grubHD
eof
		else
			log " ...... Could Not Find Boot Files For Grub Legacy.  This Is Normal If Grub2 Is Being Used."
			log " Otherwise, You Need To Manually Set Grub Root Using The Host Argument grubRoot="
		fi
	else
		log " ...... Grub Is Not Required"
	fi
}


function create_partition_layout()
{
	local partitionsCreated
	local createDynamic
	
	if [ "$(parse_json "$hd_schema" .IsValid)" = "true" ]; then
		log " ...... HD Meets The Minimum Sized Required"		
	elif [ "$(parse_json "$hd_schema" .IsValid)" = "false" ]; then
		log " ...... $(parse_json "$hd_schema" .Message)" "display"
		sleep 10
		continue		
	elif [ "$(parse_json "$hd_schema" .IsValid)" = "original" ]; then
		log " ...... HD Matches Original Size Of Image, Dynamic Partition Layout Will Not Be Used"
	else
		error "Unknown Error Occurred While Determining Minimum HD Size Required.  Check The Exception Log"
	fi
	
	erase_mbr_gpt
	restore_mbr_gpt
		
	
	if [ "$(parse_json "$hd_schema" .IsValid)" = "true" ] || [ "$force_dynamic_partitions" = "true" ] || [ "$partition_method" = "script" ] || [ "$partition_method" = "layout" ]; then
		log " ** Creating Partition Table On $hd ** " "display"
	
		$curlAuth --data "imageProfileId=$profile_id&hdToGet=$image_hd_to_use&newHDSize=$newHDSize&clientHD=$hd&taskType=deploy" "${web}GetPartLayout" $curlEnd | dos2unix > /tmp/newPartLayout
		cat /tmp/newPartLayout >> /tmp/clientlog.log
		
		
		partCreatedCounter=0
		if [ "$(parse_json "$hd_schema" .PartitionType)" = "gpt" ]; then
			while [ "$partitionsCreated" != "true" ]; do		
				delete_all_partitions $hd
				bash /tmp/newPartLayout
				partprobe &>/dev/null
				gptPartCount=$(gdisk -l $hd 2> /dev/null| awk '/^ / {print $1}' | grep -vi mbr | grep -vi gpt | grep -vi bsd | grep -vi apm -c)
				if [ "$gptPartCount" = "$(parse_json "$hd_schema" .PhysicalPartitionCount)" ]; then
					partitionsCreated=true
					log " ...... Success" "display"
				else
					partCreatedCounter=$(( $partCreatedCounter + 1 ))
					log " ...... Could Not Create Partition Layout.  Retrying Attempt $partCreatedCounter"
					if [ "$partCreatedCounter" -gt "10" ]; then
						error "Could Not Create Partition Layout"
					fi
				fi
			done
		else
			delete_all_partitions $hd
			bash /tmp/newPartLayout
			partprobe &>/dev/null
			mbrPartCount=$(fdisk -l 2>/dev/null | grep $hd | grep -v ${hd}: -c)
			if [ "$mbrPartCount" != "$(parse_json "$hd_schema" .PhysicalPartitionCount)" ]; then
				error "Could Not Create Partition Layout"
			fi
		fi
	fi
	
	
	
	log " ** New Partition Table Is ** "
	if [ "$(parse_json "$hd_schema" .PartitionType)" = "gpt" ]; then
		gdisk -l $hd &>>/tmp/clientlog.log
	else
		fdisk -l &>>/tmp/clientlog.log
	fi
	
	
	if [ "$usingHybrid" = "true" ]; then
		create_hybrid_gpt
	fi
	
	if [ "$(parse_json "$hd_schema" .UsesLvm)" = "true" ]; then
	if [ "$(parse_json "$hd_schema" .IsValid)" = "original" ]; then
		log "Creating Original LVM"
		$curlAuth --data "profileId=$profile_id&clientHd=$hd&hdToGet=$image_hd_to_use" "${web}GetOriginalLvm" $curlEnd | dos2unix > /tmp/lvmcommands
		cat /tmp/lvmcommands >> /tmp/clientlog.log
	fi
	if [ -s "/tmp/lvmcommands" ]; then
	  dmsetup remove_all
		lvmVGS=$(vgs --noheadings | awk '/^ / {print $1}')
		for VG in $lvmVGS; do
			vgremove $VG -fy
		done
	
		lvmPVS=$(pvs --noheadings | grep $hd | awk '/^ / {print $1}')
		for PV in $lvmPVS; do
			pvremove $PV -fy
		done
	
		bash /tmp/lvmcommands &>>/tmp/clientlog.log
		vgscan
		
		lvmVGS=$(vgs --noheadings | awk '/^ / {print $1}')
		for VG in $lvmVGS; do
			lvmLVS=$(lvs | grep "$VG" | awk '/^ / {print $1}')
			vgUUID=$(vgs -v  2>/dev/null | grep "$VG" | awk '/^ / {print $9}')
			sed -i "s/$vgUUID/$(cat /tmp/vg-$VG)/g" /tmp/lvm-$VG 
			for logical_volume in $lvmLVS; do		
				lvUUID=`lvs -v 2>/dev/null | grep "$lvmVG" | grep "$logical_volume" | awk '/^ / {print $10}'`
				sed -i "s/$lvUUID/$(cat /tmp/$VG-$logical_volume)/g" /tmp/lvm-$VG 
			done
			vgcfgrestore $VG -f /tmp/lvm-$VG
		done
					
	else
		return 0

	fi
	fi

	
	
}

function create_hybrid_gpt()
{
	#Fix Me
	#Hybrid gpt is rare, this is a basic way to recreate it, and will not work in some situations
	#This only creates the first 3 gpt partitions it finds
gdisk $hd << eof >> /tmp/clientlog.log
r
h
2 3 4 5 6 7 8 9 10
y

n

n

n

n

w
y
eof

	hboot=`curl -sSkL "${web}GetHdParameter?imgName=$imgName&paramName=boot&hdToGet=$hdToGet&partNumber=0" --connect-timeout 10 --stderr -`
	hbootPart=`echo $hboot | awk -f $hd ' {print $2}'`
fdisk $hd << eof >> /tmp/clientlog.log
x
M
r
a
$hbootPart
w
q
eof
}

function process_scripts()
{
	
	mkdir /scripts
	log " ** Running Script(s) ** " "display"
	sleep 1
	cd /scripts
	arr=$(echo "$hostScripts" | tr "," "\n");
	for script in $arr; do
	
		curl -sSk -H "Authorization: "$(echo -n "$WDS_KEY" | base64)"" -FscriptName="$script" "${web}DownloadCustomScripts" -o /scripts/"$script" --connect-timeout 10 --stderr - >> /tmp/clientlog.log
		log " ...... Running $script" "display"
		sleep 1
		chmod +x "$script"
		./$script "$hd" "$taskArgs"
		sleep 1
		echo
	done
}



function update_bcd()
{
	local partition=$1
	windowsPart="";bcdPart="";
	#FIX ME
	#If more than one partition has winload.exe only the first one found is used.
	log " ** Fixing BCD ** " "display"
	mkdir /mnt/ntfs
	

		ntfs-3g -o force,rw,remove_hiberfile $partition /mnt/ntfs 2> /dev/null
		if [ -f "/mnt/ntfs/Windows/System32/winload.exe" ] || [ -f "/mnt/ntfs/Windows/system32/winload.exe" ]; then
			log " ...... Found Windows Partition On $hd$x" "display"
			windowsPart=$hd$x		
			partitionOffset=$(parted -s $hd unit b print all | grep " $x " -m 1 | awk -F' ' '{print $2}' | sed 's/B//g')			
		fi
		
		if [ -f "/mnt/ntfs/Boot/BCD" ]; then
			log " ...... Found BCD Partition On $hd$x" "display"
			bcdPart=$hd$x
			reged -x /mnt/ntfs/Boot/BCD . Objects /tmp/regbcd >> /dev/null
			originalBCD=`cat /tmp/regbcd`
		fi
		umount /mnt/ntfs

	
	if [ -n "$windowsPart" ] && [ -n "$bcdPart" ]; then
		modifiedBCD=`curl -sSk -Fbcd="$(echo -n "$originalBCD" | base64)" -FoffsetBytes="$(echo -n "$partitionOffset" | base64)" "${web}AlignBcdToPartition" --connect-timeout 10 --stderr -`
		echo $modifiedBCD | base64 -d >>/tmp/modifiedbcd
		log " ** New BCD Is ** "
		cat /tmp/modifiedbcd >> /tmp/clientlog.log
		
		ntfs-3g -o force,rw,remove_hiberfile $bcdPart /mnt/ntfs 2> /dev/null
		reged -I -C /mnt/ntfs/Boot/BCD . /tmp/modifiedbcd >> /tmp/clientlog.log
		umount /mnt/ntfs
		log " ...... Success" "display"
		
	else
		log " ...... Could Not Verify Windows Partition Or BCD Partition.  BCD Has Not Been Changed" "display"
		log " ...... windowsPart: $windowsPart bcdPart: $bcdPart" 
	fi	
}

function fix_ntfs_boot()
{
	local partition=$1

		log " ...... hboot: $hboot"

		log " ** Fixing NTFS Geometry ** " "display"
		partclone.ntfsfixboot -p $partition >> /tmp/clientlog.log
		partclone.ntfsfixboot -w $partition >> /tmp/clientlog.log
		
}

function erase_mbr_gpt()
{
	log " ** Clearing MBR / GPT ** "
	sgdisk -Z $hd &>>/tmp/clientlog.log
	dd if=/dev/zero of=$hd bs=512 count=2047 &>>/tmp/clientlog.log
	partprobe &> /dev/null
}


function delete_all_partitions()
{
	#Delete all partitions but keep boot record intact
	log " ** Deleting Existing Partitions ** "
	if [ "$(parse_json "$hd_schema" .PartitionType)" = "gpt" ]; then
	gptPartCount=$(gdisk -l $1 2> /dev/null| awk '/^ / {print $1}' | grep -vi mbr | grep -vi gpt | grep -vi bsd | grep -vi apm -c)
	deleteCounter=0
		while [ "$gptPartCount" -gt "0" ]; do
			deleteCounter=$(( $deleteCounter + 1 ))
			echo "gdisk $1 &>/dev/null <<GDISK" > /tmp/partitionDelete
			for part_num in $(gdisk -l $1 2> /dev/null | awk '/^ / {print $1}' | grep -vi mbr | grep -vi gpt | grep -vi bsd | grep -vi apm); do			
				echo d >> /tmp/partitionDelete
				echo "$part_num" >> /tmp/partitionDelete
			done
			
			echo w >> /tmp/partitionDelete
			echo y >> /tmp/partitionDelete
			echo y >> /tmp/partitionDelete
			echo q >> /tmp/partitionDelete
			echo GDISK >> /tmp/partitionDelete
			cat /tmp/partitionDelete >> /tmp/clientlog.log
			bash /tmp/partitionDelete
			
			gdisk $1 &>/dev/null <<GDISK
d
$part_num
w
y
y
q
GDISK
			gptPartCount=$(gdisk -l $1 2> /dev/null | awk '/^ / {print $1}' | grep -vi mbr | grep -vi gpt | grep -vi bsd | grep -vi apm -c)
			if [ "$deleteCounter" -gt "1000" ]; then
				log " ...... Partitions Still Exist"
				gdisk -l $1 &>>/tmp/clientlog.log
				error "Could Not Delete GPT Partitions"
				
			fi
		done		
	else
		mbrPartCount=$(fdisk -l 2>/dev/null | grep $hd | grep -v ${hd}: -c)
		log "$mbrPartCount"
		deleteCounter=0
		while [ "$mbrPartCount" -gt "0" ]; do
			deleteCounter=$(( $deleteCounter + 1 ))
			fdisk $1 &>/dev/null <<FDISK
d


w
FDISK
			mbrPartCount=$(fdisk -l 2>/dev/null | grep $hd | grep -v ${hd}: -c)
			if [ "$deleteCounter" -gt "1000" ]; then
				log " ...... Partitions Still Exist"
				fdisk -l &>>/tmp/clientlog.log
				error "Could Not Delete MBR Partitions"			
			fi
		done
	fi
}

function change_computer_name()
{
	local partition=$1
	if [ -n "$hostName" ]; then
		mkdir -p /win
		
		
			if [ "$fsType" = "ntfs" ]; then
				log " ** Changing Host Name On $partition ** " "display"
				sleep 1
		
				ntfs-3g -o force,rw,remove_hiberfile $hd$x /win &>/dev/null
				if [ "$?" = "0" ]; then
					#Win 8
					if [ -f "/win/Windows/System32/Sysprep/unattend.xml" ]; then
						log " ...... Found Answer File, Changing Host Name" "display"
						rm /win/Windows/System32/Sysprep/unattend.xml
						cd /win/Windows/Panther
						cat unattend.xml | sed -e s/CrucibleWDS/$hostName/ > unattend.tmp
						mv unattend.tmp unattend.xml
					#Win 7 and Vista
					elif [ -f "/win/Windows/System32/sysprep/unattend.xml" ]; then
						log " ...... Found Answer File, Changing Host Name" "display"
						rm /win/Windows/System32/sysprep/unattend.xml
						cd /win/Windows/Panther
						cat unattend.xml | sed -e s/CrucibleWDS/$hostName/ > unattend.tmp
						mv unattend.tmp unattend.xml
					#Win XP
					elif [ -f "/win/Sysprep/sysprep.inf" ]; then
						log " ...... Found Answer File, Changing Host Name" "display"
						cd /win/Sysprep
						cat sysprep.inf | sed -e s/CrucibleWDS/$hostName/ > sysprep.tmp
						mv sysprep.tmp sysprep.inf
					else
						log " ...... Could Not Find Answer File, Attempting Registry Change" "display"
						root="/win/Windows/System32/config/SYSTEM"
						hnkey1="\ControlSet001\Services\Tcpip\Parameters\NV Hostname"
						hnkey2="\ControlSet001\Control\ComputerName\ComputerName\ComputerName"
						update_registry_key
					
						hnkey1="\ControlSet001\Services\Tcpip\Parameters\Hostname"
						hnkey1="\ControlSet001\Services\Tcpip\Parameters\HostName"
						update_registry_key
						
						hnkey1="\ControlSet001\Services\Tcpip\Parameters\NV HostName"
						hnkey2="\ControlSet001\Control\ComputerName\ComputerName\ComputerName"
						update_registry_key		

						root="/win/Windows/System32/config/SYSTEM"
						hnkey1="\ControlSet001\services\Tcpip\Parameters\NV Hostname"
						hnkey2="\ControlSet001\Control\ComputerName\ComputerName\ComputerName"
						update_registry_key		

						root="/win/Windows/System32/config/SYSTEM"
						hnkey1="\ControlSet001\services\Tcpip\Parameters\NV Hostname"
						hnkey2="\ControlSet001\Control\ComputerName\ComputerName\ComputerName"
						update_registry_key		

						root="/win/WINDOWS/system32/config/system"
						hnkey1="\ControlSet001\Services\Tcpip\Parameters\NV Hostname"
						hnkey2="\ControlSet001\Control\ComputerName\ComputerName\ComputerName"
						update_registry_key
					fi
					echo
					cd /
					umount /win	
				fi
			fi
		
	else
		log " ...... Could Not Determine The Host Name Of This Machine.  Host Name Has Not Been Changed."
	fi
}

function update_registry_key()
{
	reged -e "$root" &>/dev/null  <<EOFN 
ed $hnkey1
$hostName
ed $hnkey2
$hostName
q
y
EOFN

}

function main()
{

  log_boot_args

  if [ "$is_ondemand" = "true" ]; then
    log " ** Using On Demand Mode ** "
	for arg in "$ondemand_arguments"; do case "$arg" in *=*) eval "$arg"; log "$arg"; esac; done
  else
    checkin
	cd_reporter $computer_id wim true &
	if [ "$multicast" = "true" ]; then
	  $curlAuth --data "computerId=$computer_id" "${web}UpdateStatusInProgress" $curlEnd
	else
	  log " ** Checking Current Queue ** " "display"	
      while true; do
	    queue_status=$($curlAuth --data "computerId=$computer_id" "${web}CheckQueue" $curlEnd)
		if [ "$(parse_json "$queue_status" .Result)" = "true" ]; then
		  break
		else
		  echo "** Queue Is Full, Waiting For Open Slot ** "
		  echo " ...... Current Position $(parse_json "$queue_status" .Position)"
		  sleep 5
		fi
      done
	fi	  		
  fi

  sleep 2

  mount_smb

  process_hard_drives

  if [ -n "$hostScripts" ]; then
		process_scripts
  fi
	
  checkout
}

is_ondemand="$1"
ondemand_arguments="$2"
main "$@"

