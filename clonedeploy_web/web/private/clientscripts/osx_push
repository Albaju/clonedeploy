#!/bin/bash

. /usr/local/bin/osx_global_functions

function create_all_partition_layouts
{
  #The partition layout for all hard drives must be created before any imaging can begin
  #In the case that Core storage spans across multiple disks
  get_hard_drives "deploy"
   imaged_schema_drives=""
  current_hd_number=-1
  for hard_drive in $hard_drives; do
    echo
    log " ** Processing $hard_drive ** " "display"
    current_hd_number=$(( $current_hd_number + 1 ))
	
	if [ -n "$pre_scripts" ]; then
	  process_scripts "$pre_scripts"
	fi
	
	drive_name=$(echo $hard_drive | cut -d "/" -f 3)
    logical_block_size="$(diskutil info $hard_drive | grep "Device Block Size:" | cut -d : -f2 | sed 's/Bytes//g' | sed -e 's/^[ \t]*//')"   
    hard_drive_size_bytes=$(diskutil info $hard_drive | grep "Total Size:" | cut -d "(" -f2 | cut -d " " -f1 )
	
    log "Get hd_schema:  profileId=$profile_id&clientHdNumber=$current_hd_number&newHdSize=$hard_drive_size_bytes&schemaHds=$imaged_schema_drives"
    hd_schema=$($curlAuth --data "profileId=$profile_id&clientHdNumber=$current_hd_number&newHdSize=$hard_drive_size_bytes&schemaHds=$(remove_whitespace $imaged_schema_drives)" "${web}CheckHdRequirements" $curlEnd)
    log "$hd_schema"
	
    image_hd_to_use=$(parse_json "$hd_schema" .SchemaHdNumber)
    image_path=/storage/images/$image_name/hd$image_hd_to_use

	 create_partition_layout
	 
	 imaged_schema_drives="$imaged_schema_drives $(parse_json "$hd_schema" .SchemaHdNumber) "
  done
  
  #Now that all partitions have been created check for and create corestorage
  create_cs_layouts
}

function create_cs_layouts
{
  #Check if core storage was used in original image.  /tmp/corestorage created during par
  if [ ! -f "/tmp/corestorage" ]; then
    log "Core Storage Is Not Being Used"
    return 0
  fi
  
  cat /tmp/corestorage >>$CLIENT_LOG
	#The easy one, volume groups that were only on 1 disk and contained only 1 lv
	unique_vgs=$(cat /tmp/corestorage | cut -d: -f3 | uniq -u)
	for unique_vg in $unique_vgs; do
	  vg_name=$(cat /tmp/corestorage | grep $unique_vg | cut -d: -f1)
	  vg_pv=$(cat /tmp/corestorage | grep $unique_vg | cut -d: -f2)
	  lv_name=$(cat /tmp/corestorage | grep $unique_vg | cut -d: -f4)
	  lv_size_block=$(cat /tmp/corestorage | grep $unique_vg | cut -d: -f5)
	  lv_filesystem=$(cat /tmp/corestorage | grep $unique_vg | cut -d: -f6)
	  
	  diskutil cs create "$vg_name" "$vg_pv" 2>>$CLIENT_LOG
	  new_vg_uuid=$(diskutil info $vg_pv | grep "LVG UUID:" | cut -d : -f2 | sed -e 's/^[ \t]*//')
	  diskutil cs createVolume "$new_vg_uuid" "$lv_filesystem" "$lv_name" "${lv_size_block}s"
	done
	
	
	#The hard one, volume groups that either spanned multiple disks or contained more than 1 lv
	duplicate_vgs=$(cat /tmp/corestorage | cut -d: -f3 | uniq -d)
	for duplicate_vg in $duplicate_vgs; do
	  duplicate_count=$(cat /tmp/corestorage | grep $duplicate_vg | cut -d: -f7 | uniq -d | wc -l)
	  if [ "$duplicate_count" =  "0" ]; then
	    #We are dealing with 1 volume group on 1 disk with multiple lvs
		single_lvs=$(cat /tmp/corestorage | grep $duplicate_vg | cut -d: -f7 | uniq -u)
		vg_name=$(cat /tmp/corestorage | grep $duplicate_vg | cut -d: -f1 | head -n1)
	    vg_pv=$(cat /tmp/corestorage | grep $duplicate_vg | cut -d: -f2 | head -n1)
		diskutil cs create "$vg_name" "$vg_pv" 2>>$CLIENT_LOG
		new_vg_uuid=$(diskutil info $vg_pv | grep "LVG UUID:" | cut -d : -f2 | sed -e 's/^[ \t]*//')
		for single_lv in $single_lvs; do
		  lv_name=$(cat /tmp/corestorage | grep $duplicate_vg | grep $single_lv | cut -d: -f4)
	      lv_size_block=$(cat /tmp/corestorage | grep $duplicate_vg | grep $single_lv | cut -d: -f5)
	      lv_filesystem=$(cat /tmp/corestorage | grep $duplicate_vg | grep $single_lv | cut -d: -f6)
		  diskutil cs createVolume "$new_vg_uuid" "$lv_filesystem" "$lv_name" "${lv_size_block}s"
		done
	  else
	    #We are dealing with 1 volume group spanned across multiple disks with 1 or more lvs
		spanned_lvs=$(cat /tmp/corestorage | grep $duplicate_vg | cut -d: -f7 | uniq -d)		
	    vg_name=$(cat /tmp/corestorage | grep $duplicate_vg | cut -d: -f1 | head -n1)
		for spanned_lv in $spanned_lvs; do
		  first_vg_pv=$(cat /tmp/corestorage | grep $duplicate_vg | grep $spanned_lv | cut -d: -f2 | head -n1)
		  diskutil cs create "$vg_name" "$first_vg_pv" 2>>$CLIENT_LOG
		  new_vg_uuid=$(diskutil info $first_vg_pv | grep "LVG UUID:" | cut -d : -f2 | sed -e 's/^[ \t]*//')
		  remaining_vg_pvs=$(cat /tmp/corestorage | grep $duplicate_vg | grep $spanned_lv | cut -d: -f2 | grep -vw $first_vg_pv)
		  for vg_pv in $remaining_vg_pvs; do
	        diskutil cs addDisk "$new_vg_uuid" "$vg_pv"
	      done
		done   
	  fi
	done
}

function process_hard_drives()
{
  create_all_partition_layouts
  
  #Do it all again, There may be new hard drives listed now that all partitions have been created because of Core Storage
  local drive_name
  local lbs
  local drive_size_block
  
  get_hard_drives "deploy"

  imaged_schema_drives=""
  current_hd_number=-1
  for hard_drive in $hard_drives; do
    echo
    log " ** Processing $hard_drive ** " "display"
    current_hd_number=$(( $current_hd_number + 1 ))
	
	if [ -n "$pre_scripts" ]; then
	  process_scripts "$pre_scripts"
	fi
	
	drive_name=$(echo $hard_drive | cut -d "/" -f 3)
    logical_block_size="$(diskutil info $hard_drive | grep "Device Block Size:" | cut -d : -f2 | sed 's/Bytes//g' | sed -e 's/^[ \t]*//')"   
    hard_drive_size_bytes=$(diskutil info $hard_drive | grep "Total Size:" | cut -d "(" -f2 | cut -d " " -f1 )
	
    log "Get hd_schema:  profileId=$profile_id&clientHdNumber=$current_hd_number&newHdSize=$hard_drive_size_bytes&schemaHds=$imaged_schema_drives"
    hd_schema=$($curlAuth --data "profileId=$profile_id&clientHdNumber=$current_hd_number&newHdSize=$hard_drive_size_bytes&schemaHds=$(remove_whitespace $imaged_schema_drives)" "${web}CheckHdRequirements" $curlEnd)
    log "$hd_schema"
	
    image_hd_to_use=$(parse_json "$hd_schema" .SchemaHdNumber)
    image_path=/storage/images/$image_name/hd$image_hd_to_use
	
    process_partitions
	
    imaged_schema_drives="$imaged_schema_drives $(parse_json "$hd_schema" .SchemaHdNumber) "
	
	if [ -n "$post_scripts" ]; then
	  process_scripts "$post_scripts"
	fi
done
}

function process_partitions()
{
  local partition_size_mb
  local array_index=-1
  
  if [ "$file_copy" = "True" ]; then
    log "file_copy_schema: profileId=$profile_id"
	 file_copy_schema=$($curlAuth --data "profileId=$profile_id" "${web}GetFileCopySchema" $curlEnd)
  fi
	
  while [  "$(( $array_index + 1 ))" -lt "$(parse_json "$hd_schema" .PhysicalPartitionCount)" ]; do
    array_index=$(( $array_index + 1))
    clear_and_move_down
    current_partition="$(parse_json "$hd_schema" .PhysicalPartitions[$array_index])"
    log "$current_partition"

	if [ "$(parse_json "$current_partition" .Type)" = "EFI" ] || [ "$(parse_json "$current_partition" .Type)" = "Efi" ]; then
	  continue
	fi
	
	if [ "$(parse_json "$current_partition" .Type)" = "Boot OS X" ] || [ "$(parse_json "$current_partition" .Type)" = "boot os x" ]; then
	  continue
	fi
	
 
	get_partitions_according_to_mbr_gpt
	partition_counter=0
	for partition in $mbr_gpt_partitions; do
      partition_counter=$(( $partition_counter + 1 ))
      partition_number=`echo $partition | awk -F $hard_drive ' {print $2}' | sed 's/[^0-9]//g'`
      if [ "$(parse_json "$current_partition" .Number)" = "$partition_number" ]; then
	    partition_prefix=$(echo $partition | awk -F $hard_drive ' {print $2}' | sed 's/[0-9]*//g')
		break;
	  else
        partition_prefix=""
      fi
	done
	
	partition_size_bytes=$(diskutil info ${hard_drive}${partition_prefix}$(parse_json "$current_partition" .Number)  | grep "Total Size:" | cut -d "(" -f2 | cut -d " " -f1)
    download_image "$current_partition" part
			
	#if [ -n "$computer_name" ] && [ "$change_computer_name" = "true" ]; then
	  #Fix Me: not working
	  #chroot /Volumes/"$(parse_json "$current_partition" .Type)"
	  #if [ "$?" = "0" ]; then
        #scutil --set ComputerName "$computer_name"
        #scutil --set HostName "$computer_name"
        #scutil --set LocalHostName "$computer_name"
		#exit
	  #fi
	#fi
		
	if [ "$file_copy" = "True" ]; then
	  process_file_copy "$current_partition" "partition"
	fi
  done
}

function download_image()
{
  local current_object="$1"
  local file_name_prefix="$2"
  local destination
  local asr_verb   
 
  destination=${hard_drive}${partition_prefix}$(parse_json "$current_object" .Number)
  file_name_prefix=part"$(parse_json "$current_object" .Number)"
  
  log "partition size bytes: $partition_size_bytes"
  if [ "$partition_size_bytes" -gt "5368709120" ]; then
    asr_verb="restore"
  else
    asr_verb="restoreexact"
  fi
  
  log " ** Starting Image Download For $destination ** " "display" 
  if [ -n "$computer_id" ]; then    
    null=$($curlAuth --data "computerId=$computer_id&partition=$destination" "${web}UpdateProgressPartition" $curlEnd)
  fi
  sleep 7
  echo
	
  touch /tmp/osx.progress
	  . osx_reporter & asr $asr_verb --source $image_path/$file_name_prefix.dmg --target $destination --erase --noprompt --noverify --puppetstrings 2>> $CLIENT_LOG | tee /tmp/osx.progress
	  log ". osx_reporter &  asr $asr_verb --source $image_path/$file_name_prefix.dmg --target $destination --erase --noprompt --noverify --puppetstrings 2>> $CLIENT_LOG | tee /tmp/osx.progress"
	  sleep 5
	  
	  killall osx_reporter &>/dev/null
	  rm /tmp/osx.progress
}

function create_partition_layout()
{
  local layout_created_successfully
  local layout_failed_counter
  local gpt_partition_count
  local mbr_partition_count
  local preexisting_volume_groups
  local preexisting_physical_volumes
  local new_volume_groups
  local new_logical_volumes
  local volume_group_uuid
  local logical_volume_uuid
  
  if [ "$(parse_json "$hd_schema" .IsValid)" = "true" ] || [ "$(parse_json "$hd_schema" .IsValid)" = "original" ]; then
    log " ...... HD Meets The Minimum Sized Required"
  elif [ "$(parse_json "$hd_schema" .IsValid)" = "false" ]; then
    log " ...... $(parse_json "$hd_schema" .Message)" "display"
    sleep 10
    continue		
  else
    error "Unknown Error Occurred While Determining Minimum HD Size Required.  Check The Exception Log"
  fi
	
  erase_mbr_gpt

  
  get_partitions_according_to_mbr_gpt
	partition_counter=0
	for partition in $mbr_gpt_partitions; do
      partition_counter=$(( $partition_counter + 1 ))
      partition_number=`echo $partition | awk -F $hard_drive ' {print $2}' | sed 's/[^0-9]//g'`
      partition_prefix=`echo $partition | awk -F $hard_drive ' {print $2}' | sed 's/[0-9]*//g'`
	  break
	done
  
  if [ "$partition_method" = "script" ]; then # create partitions from image profile script
     log " ** Creating Partition Table On $hard_drive From Custom Script ** " "display"
    $curlAuth --data "profileId=$profile_id" "${web}GetCustomPartitionScript" $curlEnd > /tmp/newPartLayout
	cat /tmp/newPartLayout >> $CLIENT_LOG
    bash /tmp/newPartLayout
  else
    log " ** Creating Partition Table On $hard_drive ** " "display"
    log "imageProfileId=$profile_id&hdToGet=$image_hd_to_use&newHDSize=$hard_drive_size_bytes&clientHD=$hard_drive&taskType=deploy&partitionPrefix=$partition_prefix ${web}GetPartLayout" 
    $curlAuth --data "imageProfileId=$profile_id&hdToGet=$image_hd_to_use&newHDSize=$hard_drive_size_bytes&clientHD=$hard_drive&taskType=deploy&partitionPrefix=$partition_prefix" "${web}GetPartLayout" $curlEnd > /tmp/newPartLayout
	if [ "$(cat /tmp/newPartLayout)" = "failed" ]; then
	  error "Could Not Dynamically Create Partition Layout"
	fi
		
	  log " ** Partition Creation Script ** "
      cat /tmp/newPartLayout >> $CLIENT_LOG
      bash /tmp/newPartLayout
	  bash /tmp/createPartitions
  fi 
	
  log " ** New Partition Table Is ** "
  diskutil list $hard_drive >> $CLIENT_LOG 2>&1
  
	
 
}



function get_partitions_according_to_mbr_gpt()
{
  mbr_gpt_partitions=""
  partitions_suffix=$(diskutil list | grep $drive_name | grep -vw $hard_drive | grep -vw $drive_name | grep -vi "volume on" | awk -F"$drive_name"  '{print $2}' )
	for suffix in $partitions_suffix; do
	  mbr_gpt_partitions="$mbr_gpt_partitions $hard_drive$suffix"
	done
}



function erase_mbr_gpt()
{
  log " ** Clearing MBR / GPT ** "
  dd if=/dev/zero of=$hard_drive bs=512 count=2047 >>$CLIENT_LOG 2>&1
}


function change_computer_name()
{  
  local partition="$1"
  log " ** Changing Computer Name On $partition ** " "display"
 
}

function main()
{
  
  if [ "$is_ondemand" = "true" ]; then
    log " ** Using On Demand Mode ** "
	for arg in "$ondemand_arguments"; do case "$arg" in *=*) eval "$arg"; log "$arg"; esac; done
  else
	  log " ** Checking Current Queue ** " "display"	
      while true; do
	    queue_status=$($curlAuth --data "computerId=$computer_id" "${web}CheckQueue" $curlEnd)
		if [ "$(parse_json "$queue_status" .Result)" = "true" ]; then
		  break
		else
		  echo "** Queue Is Full, Waiting For Open Slot ** "
		  echo " ...... Current Position $(parse_json "$queue_status" .Position)"
		  sleep 5
		fi
      done
	    log " ...... Complete" "display"
		echo
		  		
  fi

  sleep 2

  mount_smb

  process_hard_drives

  #set the system startup disk - bless no longer works in el cap - I strongly dislike sip
  systemsetup -setstartupdisk "Macintosh HD"
  
  checkout
}

is_ondemand="$1"
ondemand_arguments="$2"
main "$@"

