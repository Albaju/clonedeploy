#!/bin/bash

. /usr/local/bin/osx_global_functions

function pre
{
   get_hard_drives "deploy"
   imaged_schema_drives=""
  current_hd_number=-1
  for hard_drive in $hard_drives; do
    echo
    log " ** Processing $hard_drive ** " "display"
    current_hd_number=$(( $current_hd_number + 1 ))
	
	if [ -n "$pre_scripts" ]; then
	  process_scripts "$pre_scripts"
	fi
	
	drive_name=$(echo $hard_drive | cut -d "/" -f 3)
    logical_block_size="$(diskutil info $hard_drive | grep "Device Block Size:" | cut -d : -f2 | sed 's/Bytes//g' | sed -e 's/^[ \t]*//')"   
    hard_drive_size_bytes=$(diskutil info $hard_drive | grep "Total Size:" | cut -d "(" -f3 | cut -d " " -f2 )
	
    log "Get hd_schema:  profileId=$profile_id&clientHdNumber=$current_hd_number&newHdSize=$hard_drive_size_bytes&schemaHds=$imaged_schema_drives"
    hd_schema=$($curlAuth --data "profileId=$profile_id&clientHdNumber=$current_hd_number&newHdSize=$hard_drive_size_bytes&schemaHds=$(remove_whitespace $imaged_schema_drives)" "${web}CheckHdRequirements" $curlEnd)
    log "$hd_schema"
	
    image_hd_to_use=$(parse_json "$hd_schema" .SchemaHdNumber)
    image_path=/storage/images/$image_name/hd$image_hd_to_use
	
	 imaged_schema_drives="$imaged_schema_drives $(parse_json "$hd_schema" .SchemaHdNumber) "
  done
}

function process_hard_drives()
{
  local drive_name
  local lbs
  local drive_size_block
  
  get_hard_drives "deploy"

  imaged_schema_drives=""
  current_hd_number=-1
  for hard_drive in $hard_drives; do
    echo
    log " ** Processing $hard_drive ** " "display"
    current_hd_number=$(( $current_hd_number + 1 ))
	
	if [ -n "$pre_scripts" ]; then
	  process_scripts "$pre_scripts"
	fi
	
	drive_name=$(echo $hard_drive | cut -d "/" -f 3)
    logical_block_size="$(diskutil info $hard_drive | grep "Device Block Size:" | cut -d : -f2 | sed 's/Bytes//g' | sed -e 's/^[ \t]*//')"   
    hard_drive_size_bytes=$(diskutil info $hard_drive | grep "Total Size:" | cut -d "(" -f3 | cut -d " " -f2 )
	
    log "Get hd_schema:  profileId=$profile_id&clientHdNumber=$current_hd_number&newHdSize=$hard_drive_size_bytes&schemaHds=$imaged_schema_drives"
    hd_schema=$($curlAuth --data "profileId=$profile_id&clientHdNumber=$current_hd_number&newHdSize=$hard_drive_size_bytes&schemaHds=$(remove_whitespace $imaged_schema_drives)" "${web}CheckHdRequirements" $curlEnd)
    log "$hd_schema"
	
    image_hd_to_use=$(parse_json "$hd_schema" .SchemaHdNumber)
    image_path=/storage/images/$image_name/hd$image_hd_to_use
	
    create_partition_layout
	
	#if lvm is in use, all hard drives must have partitions created before imaging can begin in the event that the volume group spans multiple disks
	 if [ "$(parse_json "$hd_schema" .UsesLvm)" = "true" ]; then
       continue
     fi
    process_partitions
	
    imaged_schema_drives="$imaged_schema_drives $(parse_json "$hd_schema" .SchemaHdNumber) "
	
	if [ -n "$post_scripts" ]; then
	  process_scripts "$post_scripts"
	fi
done
}

function process_partitions()
{
  local partition_size_mb
  local array_index=-1
  
  if [ "$file_copy" = "True" ]; then
    log "file_copy_schema: profileId=$profile_id"
	 file_copy_schema=$($curlAuth --data "profileId=$profile_id" "${web}GetFileCopySchema" $curlEnd)
  fi
	
  while [  "$(( $array_index + 1 ))" -lt "$(parse_json "$hd_schema" .PhysicalPartitionCount)" ]; do
    array_index=$(( $array_index + 1))
    clear_and_move_down
    current_partition="$(parse_json "$hd_schema" .PhysicalPartitions[$array_index])"
    log "$current_partition"
	
 
	get_partitions_according_to_mbr_gpt
	partition_counter=0
	for partition in $mbr_gpt_partitions; do
      partition_counter=$(( $partition_counter + 1 ))
      partition_number=`echo $partition | awk -F $hard_drive ' {print $2}' | sed 's/[^0-9]//g'`
      if [ "$(parse_json "$hd_schema" .Number)" = "$partition_number" ]; then
	    partition_prefix=$(echo $partition | awk -F $hard_drive ' {print $2}' | sed 's/[0-9]*//g')
	  else
        partition_prefix=""
      fi
	done
	
	partition_size_bytes=$(diskutil info ${hard_drive}${partition_prefix}$(parse_json "$current_partition" .Number)  | grep "Total Size:" | cut -d "(" -f2 | cut -d " " -f1)
    download_image "$current_partition" part
		
    if [ "$skip_expand_volumes" != "true" ]; then 
      if [ "$(parse_json "$current_partition" .ImageType)" = "Block" ] && [ "$partition_size_bytes" -gt "5368709120" ]; then #partition smaller than 5GB probably that way for a reason, leave it alone.
        expand_volume ${hard_drive}${partition_prefix}$(parse_json "$current_partition" .Number) 
      fi
    fi
		
	if [ "$(parse_json "$current_partition" .FileSystem)" = "ntfs" ] && [ -n "$computer_name" ] && [ "$change_computer_name" = "true" ]; then
      change_computer_name ${hard_drive}${partition_prefix}$(parse_json "$current_partition" .Number)
	fi
		
	if [ "$file_copy" = "True" ]; then
	  process_file_copy "$current_partition" "partition"
	fi
  done
}

function download_image()
{
  local current_object="$1"
  local file_name_prefix="$2"
  local destination
    
 
    destination=${hard_drive}${partition_prefix}$(parse_json "$current_object" .Number)
    file_name_prefix=part"$(parse_json "$current_object" .Number)"
  
  
  log " ** Starting Image Download For $destination ** " "display" 
  if [ -n "$computer_id" ]; then    
    null=$($curlAuth --data "computerId=$computer_id&partition=$destination" "${web}UpdateProgressPartition" $curlEnd)
  fi
  sleep 7
  echo
	
  touch /tmp/osx.progress
	  . osx_reporter &  asr restoreexact --source $image_path/$file_name_prefix.dmg --target $destination --erase --noprompt --noverify --puppetstrings 2>> $CLIENT_LOG | tee /tmp/osx.progress
	
	  sleep 5
	  
	  killall osx_reporter &>/dev/null
	  rm /tmp/osx.progress
}





function create_partition_layout()
{
  local layout_created_successfully
  local layout_failed_counter
  local gpt_partition_count
  local mbr_partition_count
  local preexisting_volume_groups
  local preexisting_physical_volumes
  local new_volume_groups
  local new_logical_volumes
  local volume_group_uuid
  local logical_volume_uuid
  
  if [ "$(parse_json "$hd_schema" .IsValid)" = "true" ]; then
    log " ...... HD Meets The Minimum Sized Required"		
  elif [ "$(parse_json "$hd_schema" .IsValid)" = "false" ]; then
    log " ...... $(parse_json "$hd_schema" .Message)" "display"
    sleep 10
    continue		
  else
    error "Unknown Error Occurred While Determining Minimum HD Size Required.  Check The Exception Log"
  fi
	
  erase_mbr_gpt

  
  get_partitions_according_to_mbr_gpt
	partition_counter=0
	for partition in $mbr_gpt_partitions; do
      partition_counter=$(( $partition_counter + 1 ))
      partition_number=`echo $partition | awk -F $hard_drive ' {print $2}' | sed 's/[^0-9]//g'`
      if [ "$(parse_json "$hd_schema" .Number)" = "$partition_number" ]; then
	    partition_prefix=$(echo $partition | awk -F $hard_drive ' {print $2}' | sed 's/[0-9]*//g')
	  else
        partition_prefix=""
      fi
	done
  
  if [ "$partition_method" = "script" ]; then # create partitions from image profile script
     log " ** Creating Partition Table On $hard_drive From Custom Script ** " "display"
    $curlAuth --data "profileId=$profile_id" "${web}GetCustomPartitionScript" $curlEnd | dos2unix > /tmp/newPartLayout
	cat /tmp/newPartLayout >> $CLIENT_LOG
    bash /tmp/newPartLayout
    partprobe &>/dev/null
  else
    log " ** Creating Partition Table On $hard_drive ** " "display"
    $curlAuth --data "imageProfileId=$profile_id&hdToGet=$image_hd_to_use&newHDSize=$drive_size_bytes&clientHD=$hard_drive&taskType=deploy&partitionPrefix=$partition_prefix" "${web}GetPartLayout" $curlEnd | dos2unix > /tmp/newPartLayout
	if [ "$(cat /tmp/newPartLayout)" = "failed" ]; then
	  error "Could Not Dynamically Create Partition Layout"
	fi
		
	  log " ** Partition Creation Script ** "
      cat /tmp/newPartLayout >> $CLIENT_LOG
      bash /tmp/newPartLayout
  fi 
	
  log " ** New Partition Table Is ** "
  if [ "$(parse_json "$hd_schema" .PartitionType)" = "gpt" ]; then
    gdisk -l $hard_drive &>>$CLIENT_LOG
  else
    fdisk -l &>>$CLIENT_LOG
  fi
	
 
}



function get_partitions_according_to_mbr_gpt()
{
  mbr_gpt_partitions=""
  partitions_suffix=$(diskutil list | grep $drive_name | grep -vw $hard_drive | grep -vw $drive_name | grep -vi "volume on" | awk -F"$drive_name"  '{print $2}' )
	for suffix in $partitions_suffix; do
	  mbr_gpt_partitions="$mbr_gpt_partitions $hard_drive$suffix"
	done
}



function erase_mbr_gpt()
{
  log " ** Clearing MBR / GPT ** "
  dd if=/dev/zero of=$hard_drive bs=512 count=2047 &>>$CLIENT_LOG
}


function change_computer_name()
{  
  local partition="$1"
  log " ** Changing Computer Name On $partition ** " "display"
 
}

function main()
{
  
  log_boot_args

  if [ "$is_ondemand" = "true" ]; then
    log " ** Using On Demand Mode ** "
	for arg in "$ondemand_arguments"; do case "$arg" in *=*) eval "$arg"; log "$arg"; esac; done
  else
    checkin
	if [ "$multicast" = "true" ]; then
	  $curlAuth --data "computerId=$computer_id" "${web}UpdateStatusInProgress" $curlEnd
	else
	  log " ** Checking Current Queue ** " "display"	
      while true; do
	    queue_status=$($curlAuth --data "computerId=$computer_id" "${web}CheckQueue" $curlEnd)
		if [ "$(parse_json "$queue_status" .Result)" = "true" ]; then
		  break
		else
		  echo "** Queue Is Full, Waiting For Open Slot ** "
		  echo " ...... Current Position $(parse_json "$queue_status" .Position)"
		  sleep 5
		fi
      done
	    log " ...... Complete" "display"
		echo
	fi	  		
  fi

  sleep 2

  mount_smb

  process_hard_drives
	
  checkout
}

is_ondemand="$1"
ondemand_arguments="$2"
main "$@"

