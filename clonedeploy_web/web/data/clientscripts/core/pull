#!/bin/bash
CLIENT_LOG="/tmp/clientlog.log"
. functions

isond="$1"
taskArgs="$2"
logBootArgs

function clear_mounted_devices()
{
   log " ** Clearing Mounted Devices On $partition ** "
      ntfs-3g -o force,rw $partition /mnt/ntfs &>>/tmp/clientlog.log
      reged -e /mnt/ntfs/Windows/System32/config/SYSTEM &>>/tmp/clientlog.log <<MOUNT
cd \MountedDevices
delallv
q
y
MOUNT
      umount /mnt/ntfs &> /dev/null
    fi
  done
    log " ...... Complete"
}

function save_bcd_store()
{
  mkdir -p /mnt/ntfs 2>> /tmp/clientlog.log
  ntfs-3g -o force,rw $partition /mnt/ntfs 2> /dev/null        
  if [ -f "/mnt/ntfs/Boot/BCD" ]; then
    log " ** Original BCD ** "
    reged -x /mnt/ntfs/Boot/BCD . Objects /tmp/regbcd >>/dev/null
    cat /tmp/regbcd >> /tmp/clientlog.log
          
    cp /mnt/ntfs/Boot/BCD $image_path/BCD
    cp /mnt/ntfs/bootmgr $image_path/bootmgr
            
  fi
      umount /mnt/ntfs
}

function save_mbr_gpt()
{
  log " ** Checking For Partition Table Types Before Upload On $hard_drive ** "
    gpt_status=`gdisk -l $hard_drive <<< "q" 2>> /tmp/clientlog.log | grep 'GPT:' | awk '{$1=""; print $0}' | sed 's/^ //'`
    if [ "$gpt_status" = "present" ]; then
      usingGPT=true
      mbr_status=`gdisk -l $hard_drive <<< "q" 2>> /tmp/clientlog.log | grep 'MBR:' | awk '{$1=""; print $0}' | sed 's/^ //'`
      if [ "$mbr_status" = "MBR only" ]; then
        error "This Hard Drive Appears To Have Both GPT And MBR.  CrucibleWDS Does Not Know What To Use.  You Must First Convert The Drive To One Or The Other Before Uploading"
      fi
    elif [ "$gpt_status" = "damaged" ]; then
      error "The GPT Table Is Damaged And Cannot Be Saved.  You Must Fix This Before Uploading This Image"
    fi
    log " ...... gpt_status: $gpt_status mbr_status: $mbr_status" 
  
  log " ** Saving MBR / GPT On $hard_drive ** " "display"  

  if [ "$usingGPT" = "true" ]; then
    checkPartStart=$(gdisk $hard_drive -l | awk '/^ / {print $2+0}' | grep -vw "0" | sort -n | head -n1)
  else
    checkPartStart=$(parted -s $hard_drive unit s print all | awk -F' ' '{print $2+0}' | grep -vw "0" | sort -n | head -n1)
  fi

  toSave=$(( $checkPartStart - 1 ))
    
  log " ...... drive: $drive checkPartStart: $checkPartStart toSave: $toSave "
    
    dd if=$hard_drive of=$imgPath/table count=$toSave bs=512 &>> /tmp/clientlog.log 
    if [ -s "$imgPath/table" ]; then
      log " ...... Success" "display"
    else
      error "Could Not Save MBR /GPT .  Check Permissions."
    fi
  
  echo
  sleep 5
}

################################################################
#  Get logical volumes for current volume group
#  Global Get:
#    volume_group
#	 custom_logical_volumes
#  Global Set:
#    logical_volumes
#    logical_volume_count 
#  Arguments:
#    none
################################################################
function get_logical_volumes()
{
  local lvs
  local logical_volume
  logical_volumes=""
  if [ -n "$custom_logical_volumes" ]; then
    logical_volumes=`echo "$custom_logical_volumes" | grep "$volume_group"`
    log " ...... Logical Volumes Set By Image Profile: $logical_volumes" "display"    
  else
    lvs=$(lvs | grep "$volume_group" | awk '/^ / {print $1}')  
    #Escape - in vg or lv
    escaped_volume_group=$(echo $volume_group | sed 's/-/--/g')
    for logical_volume in $lvs; do
      escaped_logical_volume=$(echo $logical_volume | sed 's/-/--/g')
      logical_volumes="$logical_volumes $escaped_volume_group-$escaped_logical_volume"
    done
    
  fi
                  
  logical_volume_count=0
  for logical_volume in $logical_volumes; do
    logical_volume_count=$(( $logical_volume_count + 1 ))
  done
}

################################################################
#  Get partition list for current hard drive
#  Global Get:
#    custom_partitions
#	 hard_drive
#  Global Set:
#    partitions
#    partition_count  
#  Arguments:
#    display_onscreen - true|false - output log info to screen
################################################################
function get_partitions()
{
  local display_onscreen="$1"
  local partition
  
  if [ "$display_onscreen" = "true" ]; then
    log " ** Determining Partition Count On $hard_drive ** " "display"
  fi
  
  partitions=""
  if [ -n "$custom_partitions" ]; then
    for partition in $custom_partitions; do
      echo "$partition" | grep $hard_drive
      if [ "$?" = "0" ]; then
        partitions="$partitions $partition"
      fi
    done
	if [ "$display_onscreen" = "true" ]; then
	  log " ...... Partitions Set By Image Profile: $partitions" "display"
    fi
  else
    partitions=$(lsblk -ipno KNAME | grep "$hard_drive" | grep -vw "$hard_drive" 2>> /tmp/clientlog.log)  
  fi
    
  partition_count=0  
  for partition in $partitions; do
    partition_count=$(( $partition_count + 1 ))
  done
  
  if [ "$partition_count" = "0" ]; then
    error "Unable To Determine Partition Count Or There Are No Partitions On This Drive"
  fi
  
  if [ "$display_onscreen" = "true" ]; then
    log " ...... Found $partition_count Partition(s)" "display"
  fi
}

################################################################
#  Shrink the filesystem to smallest usable size
#  Global Get:
#    filesystem_type
#	 image_type
#  Global Set:
#    shrunk_volumes
#  Arguments:
#    volume_to_shrink - The partition or logical volume that
#      contains the volume to shrink
################################################################
function shrinkFS()
{
	local volume_to_shrink="$1"
	
	local new_extfs_size
	local extfs_total_blocks
	local extfs_block_size
	local extfs_volume_size_bytes
    if [ "$filesystem_type" = "ext2" ] || [ "$filesystem_type" = "ext3" ] || [ "$filesystem_type" = "ext4" ]; then
      newextsize="";
      log " ...... Shrinking EXT Volume On $volume_to_shrink (This May Take A Few Minutes) " "display"
      e2fsck -fp "$volume_to_shrink" &> /dev/null
      extfs_total_blocks=`resize2fs -P "$volume_to_shrink" 2>/dev/null | awk -F': ' '{print $2}'`;
      extfs_block_size=`dumpe2fs -h "$volume_to_shrink" 2>/dev/null | grep "^Block size:" | awk '{print $3}'`;
      extfs_volume_size_bytes=`expr $extfs_total_blocks '*' $extfs_block_size`;
      new_extfs_size=`expr $extfs_volume_size_bytes '*' 103 '/' 100 '/' 1024 '/' 1024`; #Give 3% padding 
  
      resize2fs $volume_to_shrink ${new_extfs_size}M &>> /tmp/clientlog.log
      
      if [ ! "$?" = "0" ]; then
        log "Warning, EXT File System Did Not Shrink Properly. " "display"
      else
        shrunk_volumes="$shrunk_volumes $volume_to_shrink "
        log " ...... Success" "display"
      fi

      log " ...... extfs_total_blocks: $extfs_total_blocks extfs_block_size: $extfs_block_size new_extfs_size $new_extfs_size"

    local ntfs_check
	local ntfs_volume_size_bytes
	local new_ntfs_size
    elif [ "$filesystem_type" = "ntfs" ]; then
      if [ "$image_type" = "file" ]; then #If we are doing a file based clone, the volume does not need to be shrunk
        return 0
      fi
      log " ...... Shrinking NTFS Volume On $volume_to_shrink (This May Take A Few Minutes) " "display"
      ntfs_check=`ntfsresize -i $volume_to_shrink | grep "chkdsk /f"`
      if [ "$?" = "0" ]; then
        error "$ntfs_check"
      fi
      
      ntfsfix -b -d $volume_to_shrink &>>/tmp/clientlog.log
      ntfs_volume_size_mb=`ntfsresize -f -i -P $volume_to_shrink | grep "bytes or" | cut -d" " -f8`;
      new_ntfs_size=`expr $ntfs_volume_size_mb '*' 103 '/' 100` # Give 3% padding

      ntfsresize -f -s ${new_ntfs_size}M $volume_to_shrink &>> /tmp/clientlog.log << CONFIRM 
y
CONFIRM
      if [ ! "$?" = "0" ]; then
        log "Warning, NTFS File System Did Not Shrink Properly. " "display"
      else
        shrunk_volumes"$shrunk_volumes $volume_to_shrink "
        log " ...... Success" "display"
      fi
      log " ...... ntfssize: $ntfssize"
      
      ntfsfix -b -d $volume_to_shrink &>>/tmp/clientlog.log
    fi
  
}

################################################################
#  Calculates the sizes of hard drive and partition and shrinks
#    any applicable volumes
#  Global Get:
#    filesystem_type
#	 image_type
#  Global Set:
#    shrunk_volumes
#  Arguments:
#    volume_to_shrink - The partition or logical volume that
#      contains the volume to shrink
################################################################
function calcSize()
{
  log " ** Resizing Volumes And Calculating Image Schema ** " "display"
  sleep 1
  mkdir /mnt/ntfs 2>> $CLIENT_LOG
  
  hard_drive_counter=0
  image_schema="{\"harddrives\": [ "
  for hard_drive in $hard_drives; do
    hard_drive_counter=$(( $hard_drive_counter + 1 ))
    drive_name="";logical_block_size="";physical_block_size="";hard_drive_size_bytes="";boot_partition="";gpt_status="";mbr_status="";partition_type="";hard_drive_guid="";
    drive_name=$(echo $hard_drive | cut -d "/" -f 3)
    logical_block_size=$(cat /sys/block/$drive_name/queue/logical_block_size)
    physical_block_size=$(cat /sys/block/$drive_name/queue/physical_block_size)
    hard_drive_size_bytes=$(cat /sys/block/$drive_name/size)
    boot_partition=$(sfdisk $hard_drive -l | grep "*" | grep "dev" | cut -d" " -f1)
    gpt_status=`gdisk -l $hard_drive <<< "q" 2>> /tmp/clientlog.log | grep 'GPT:' | awk '{$1=""; print $0}' | sed 's/^ //'`
    if [ "$gpt_status" = "present" ]; then
      mbr_status=`gdisk -l $hard_drive <<< "q" 2>> /tmp/clientlog.log| grep 'MBR:' | awk '{$1=""; print $0}' | sed 's/^ //'`
      partition_type="gpt"
      hard_drive_guid=`gdisk -l $hard_drive | grep GUID | awk -F': ' '{print $2}'`
      if [ "$mbr_status" = "MBR only" ]; then
        error "This Hard Drive Appears To Have Both GPT And MBR.  CrucibleWDS Does Not Know What To Use.  You Must First Convert The Drive To One Or The Other Before Uploading"
      fi
    else
      partition_type="mbr"
    fi
    hard_drive_json="{\"name\":\"$hard_drive\",\"size\":\"$hard_drive_size_bytes\",\"table\":\"$partition_type\",\"boot\":\"$boot_partition\",\"lbs\":\"$logical_block_size\",\"pbs\":\"$physical_block_size\",\"guid\":\"$hard_drive_guid\",\"active\":\"true\",\"partitions\": [ "
    
    get_partitions "false"
    
    partition_counter=0
    for partition in $partitions; do
      partition_counter=$(( $partition_counter + 1 ))
      filesystem_type="";pUUID="";pGUID="";partCloneType="";pused="";pstart="";pend="";psize="";ptype="";
      x=`echo $partition | awk -F $hard_drive ' {print $2}'`
      filesystem_type=`blkid -po udev $hard_drive$x | grep FS_TYPE | awk -F'=' '{print $2}'`
      pUUID=`blkid -po udev $hard_drive$x | grep ID_FS_UUID= | awk -F'=' '{print $2}'`
      
      if [ "$partition_type" = "gpt" ]; then
        pGUID=`sgdisk $hard_drive -i$x | grep "unique GUID" | awk -F ' ' '{print $4}'`
      fi
      
      #In addition to setting partclone type, clean filesystems for better compatibility moving forward
      if [ "$filesystem_type" = "ntfs" ]; then
        ntfsfix -b -d $hard_drive$x &>/dev/null
        ntfs-3g -o force,rw,remove_hiberfile $hard_drive$x /mnt/ntfs 2> /dev/null        
        umount /mnt/ntfs
        partCloneType="ntfs"
          
      elif [ "$filesystem_type" = "ext2" ] || [ "$filesystem_type" = "ext3" ] || [ "$filesystem_type" = "ext4" ]; then
        e2fsck -fp $hard_drive$x &> /dev/null
        partCloneType="extfs"
      elif [ "$filesystem_type" = "xfs" ]; then
        partCloneType="xfs"
      else
        partCloneType="imager"
      fi
          
      pstart=$(parted -s $hard_drive unit s print all | grep " $x " -m 1 | awk -F' ' '{print $2}' | sed 's/s//g')
      pend=$(parted -s $hard_drive unit s print all | grep " $x " -m 1 | awk -F' ' '{print $3}' | sed 's/s//g')
      psize=$(parted -s $hard_drive unit s print all | grep " $x " -m 1 | awk -F' ' '{print $4}' | sed 's/s//g')
      pMBSize=$(parted -s $hard_drive unit MB print all | grep " $x " -m 1 | awk -F' ' '{print $4}' | sed 's/MB//g')
      #GPT does not have a concept of partition type only mbr has primary, extended, or logical
      if [ "$partition_type" = "mbr" ]; then
        ptype=$(parted -s $hard_drive unit s print all | grep " $x " -m 1| awk -F' ' '{print $5}')
        fsid=$(sfdisk -c $hard_drive $x 2>> /tmp/clientlog.log)
      else
        fsid=$(gdisk $hard_drive -l | grep " $x " | awk '/^ / {print $6}')
      fi
            
      if [ "$skip_shrink_volumes" != "true" ] && [ "$upload_schema_only" != "true" ] && [ "$pMBSize" -gt "5000" ]; then #partition smaller than 5GB probably that way for a reason, leave it alone.
        if [ "$filesystem_type" = "ext2" ] || [ "$filesystem_type" = "ext3" ] || [ "$filesystem_type" = "ext4" ] || [ "$filesystem_type" = "ntfs" ]; then
          if [[ ! "$custom_fixed_partitions" == *"$hard_drive$x"* ]]; then
            shrinkFS $hard_drive$x      
          fi
        fi
      fi

      partclone.$partCloneType -SIic -s $hard_drive$x -O /dev/null >& /tmp/$x.size
      log "$hard_drive$x Volume Size"
      cat /tmp/$x.size | grep volume_size >> /tmp/clientlog.log
      cat /tmp/$x.size | grep used_size >> /tmp/clientlog.log
      volume_size=`cat /tmp/$x.size | grep volume_size | cut -d"," -f 1 | cut -d ":" -f 2` #sed 's/ *$//'
      pused=`cat /tmp/$x.size | grep used_size | cut -d"," -f 2 | cut -d ":" -f 2` #sed 's/ *$//'
      
      stringPart="{\"number\":\"$x\",\"start\":\"$pstart\",\"end\":\"$pend\",\"size\":\"$psize\",\"volumesize\":\"$volume_size\",\"type\":\"$ptype\",\"usedmb\":\"$pused\",\"fsType\":\"$filesystem_type\",\"fsid\":\"$fsid\",\"uuid\":\"$pUUID\",\"guid\":\"$pGUID\",\"active\":\"true\",\"customsize\":\"\",\"customsizeunit\":\"\",\"forcefixedsize\":\"false\",\"volumegroup\": { "
      
      #experimental lvm support
      if [ "$lvmResize" != "false" ]; then
        if [ "$fsid" = "8e" ] || [ "$fsid" = "8E00" ]; then
          vgscan &>> /tmp/clientlog.log    
          volume_group=$(pvs | grep $partition | awk '/^ / {print $2}')
          if [ "$?" = "0" ]; then
            lvmExists=true
            log " ** Displaying LVM Information ** "
            pvdisplay &>>/tmp/clientlog.log
            vgdisplay &>>/tmp/clientlog.log
            lvdisplay &>>/tmp/clientlog.log
          fi
          vgchange -a y "$volume_group"
          lvmVGUUID=$(vgs -v  2>/dev/null | grep "$volume_group" | awk '/^ / {print $9}')
          lvmVGSize=$(vgs 2>/dev/null --units s | grep "$volume_group" | awk '/^ /  {print $6}' | sed 's/S$//')
          stringVG="\"name\":\"$volume_group\",\"size\":\"$lvmVGSize\",\"type\":\"vg\",\"physicalvolume\":\"$partition\",\"uuid\":\"$lvmVGUUID\",\"logicalvolumes\": [ "
        
          get_logical_volumes
          
          lvCounter=0
          for logical_volume in $lvmLVS; do
            lvHD="/dev/mapper/$logical_volume"
            lvCounter=$(( $lvCounter + 1 ))
            filesystem_type=`blkid -po udev "$lvHD" | grep FS_TYPE | awk -F'=' '{print $2}'`
            lvUUID=`lvs -v 2>/dev/null | grep "$volume_group" | grep "$logical_volume" | awk '/^ / {print $10}'`
            lvSize=`lvs --units s | grep "$volume_group" | grep "$logical_volume" | awk '/^ / {print $4}' | sed 's/S$//'`
            #In addition to setting partclone type, clean filesystems for better compatibility moving forward
            if [ "$filesystem_type" = "ntfs" ]; then
              ntfsfix -b -d "$lvHD" &>/dev/null
              ntfs-3g -o force,rw,remove_hiberfile "$lvHD" /mnt/ntfs 2> /dev/null
              umount /mnt/ntfs
              partCloneType="ntfs"
          
            elif [ "$filesystem_type" = "ext2" ] || [ "$filesystem_type" = "ext3" ] || [ "$filesystem_type" = "ext4" ]; then
              e2fsck -fp "$lvHD" &> /dev/null
              partCloneType="extfs"
            elif [ "$filesystem_type" = "xfs" ]; then
              partCloneType="xfs"
            else
              partCloneType="imager"
            fi
          
            
            if [ "$skip_shrink_volumes" != "true" ] && [ "$upload_schema_only" != "true" ] && [ "$skip_shrink_lvm" != "true" ] && [ "$pMBSize" -gt "5000" ]; then #partition smaller than 5GB probably that way for a reason, leave it alone.
              if [ "$filesystem_type" = "ext2" ] || [ "$filesystem_type" = "ext3" ] || [ "$filesystem_type" = "ext4" ] || [ "$filesystem_type" = "ntfs" ]; then
                shrinkFS $lvHD      
              fi
            fi
            
            partclone.$partCloneType -SIic -s "$lvHD" -O /dev/null >& /tmp/lv$lvCounter.size
            log "$lvHD Volume Size"
            cat /tmp/lv$lvCounter.size | grep volume_size >> /tmp/clientlog.log
            cat /tmp/lv$lvCounter.size | grep used_size >> /tmp/clientlog.log
            lv_volume_size=`cat /tmp/lv$lvCounter.size | grep volume_size | cut -d"," -f 1 | cut -d ":" -f 2` #sed 's/ *$//'
            lvused=`cat /tmp/lv$lvCounter.size | grep used_size | cut -d"," -f 2 | cut -d ":" -f 2` #sed 's/ *$//'
          
            
            stringLV="{\"name\":\"$logical_volume\",\"size\":\"$lvSize\",\"volumesize\":\"$lv_volume_size\",\"type\":\"lv\",\"volumegroup\":\"$volume_group\",\"usedmb\":\"$lvused\",\"fstype\":\"$filesystem_type\",\"uuid\":\"$lvUUID\",\"active\":\"true\",\"customsize\":\"\",\"customsizeunit\":\"\",\"forcefixedsize\":\"false\"}"
            if [ "$lvCounter" = "$lvmLVSCount" ]; then
              stringLV="$stringLV] } }"
            else
              stringLV="$stringLV,"
            fi
          
            stringAllLVS=$stringAllLVS$stringLV
          
          done
        
          stringVGSLVS=$stringVG$stringAllLVS
        
          if [ "$partition_counter" = "$partition_count" ]; then
            stringAllParts="$stringAllParts$stringPart$stringVGSLVS] }"
          else
            stringAllParts="$stringAllParts$stringPart$stringVGSLVS,"
          fi
        else
          stringPart="$stringPart} }"
        
          if [ "$partition_counter" = "$partition_count" ]; then
            stringAllParts="$stringAllParts$stringPart] }"
          else
            stringAllParts="$stringAllParts$stringPart,"
          fi
        
        fi
      
      else
        stringPart="$stringPart} }"
        
        if [ "$partition_counter" = "$partition_count" ]; then
          stringAllParts="$stringAllParts$stringPart] }"
        else
          stringAllParts="$stringAllParts$stringPart,"
        fi
      fi
      
    done
    
    stringAllHds=$stringAllHds$hard_drive_json$stringAllParts
    if [ "$hard_drive_counter" = "$hard_drive_count" ]; then
      stringAllHds="$stringAllHds] }" 
    else
      stringAllHds="$stringAllHds,"
    fi
    
    stringAllParts=""
  done
  
  image_schema=$image_schema$stringAllHds
  
  log " ...... image_schema: $image_schema"  
  log " ...... Complete" "display"
  echo
  sleep 2 
  
  echo $image_schema > /storage/images/$image_name/schema      
}

################################################################
#  Upload the image for the current hard drive
#  Global Get:
#    partitions
#    compression_algorithm
#    compression_level
#	 computer_name
#    web
#    image_path
#  Global Set:
#    none
#  Arguments:
#    is_logical_volume - true|false
################################################################
function uploadImage()
{
  local is_logical_volume="$1"
  local partition
  local compression_extension
  local compression_binary
  local partition_number
  local partclone_type
  local mbr_filesystem_id
  local gpt_filesystem_id
  local output_name

  if [ "$compression_algorithm" = "lz4" ]; then
      compression_extension="lz4"
      compression_binary="lz4"
    elif [ "$compression_algorithm" = "gzip" ]; then
      compression_extension="gz"
      compression_binary="gzip"      
    else
      error "Could Not Determine Current Compression Algorithm: $compression_algorithm"
  fi
   
  for partition in $partitions; 
    ClearAndMoveDown
    log " ** Starting Image Upload For Partition $partition ** " "display" 
    sleep 7
    echo
    
    if [ "$is_logical_volume" = "true" ]; then
      partition_number=`echo $partition | sed 's/\/dev\/mapper\///g'`
    else
      partition_number=`echo $partition | awk -F $hard_drive ' {print $2}'`    
    fi
    
    null=`curl -sSk "${web}UpdateProgressPartition?hostName=$hostName&partition=$partition" --connect-timeout 10 --stderr -`    
    filesystem_type=`blkid -po udev $partition | grep FS_TYPE | awk -F'=' '{print $2}'`

    log " ...... partition_number: $partition_number filesystem_type: $filesystem_type"
    
    if [ "$filesystem_type" = "ntfs" ]; then    
      partclone_type="ntfs"
      save_bcd_store
	  clear_mounted_devices
    elif [ "$filesystem_type" = "vfat" ]; then
      partclone_type="fat"
      
    elif [ "$filesystem_type" = "ext2" ] || [ "$filesystem_type" = "ext3" ] || [ "$filesystem_type" = "ext4" ]; then
      partclone_type="extfs"

    elif [ "$filesystem_type" = "hfsplus" ]; then
      partclone_type="hfsp"
      #I don't know why but partclone.hfsp used with lz4 results in a corrupted image file, always use gzip with hfs
      compression_binary="gzip"
      compression_extension="gz"
    
    elif [ "$filesystem_type" = "xfs" ]; then
      partclone_type="xfs"
      
    elif [ "$filesystem_type" = "swap" ]; then
      log " ...... $partition Is A Swap Partition.  Skipping." "display"
      sleep 2
      continue  
    else
      if [ "$is_logical_volume" != "true" ]; then
        mbr_filesystem_id=$(sfdisk -c $hard_drive $partition_number 2>> /tmp/clientlog.log)
        gpt_filesystem_id=$(gdisk $hard_drive -l | grep " $partition_number " | awk '/^ / {print $6}')
      
        if [ "$mbr_filesystem_id" = "8e" ] || [ "$gpt_filesystem_id" = "8E00" ]; then
          if [ "$skip_shrink_lvm" != "true" ]; then
            log " ...... $partition Is An LVM Physical Partition.  Skipping." "display"
            log " ...... Logical Volumes Will Be Uploaded Last." "display"
            sleep 5
            continue
          fi
        fi
      fi   
      partclone_type="imager"
    fi
    
    
    
    if [ "$is_logical_volume" = "true" ]; then
      output_name=$(echo $partition_number | sed 's/--/-/g')
	else
	  output_name=part$partition
	fi
  
	touch /tmp/clone.progress
	
    log " ...... reporter $computer_name $web & partclone.$partclone_type -B -c -s $partition | $compression_binary $compression_level -c > $image_path/$output_name.$partclone_type.$compression_extension"    
    
	reporter $computer_name $web & partclone.$partclone_type -B -c -s $partition | $compression_binary $compression_level -c > $image_path/$output_name.$partclone_type.$compression_extension     
    rm /tmp/clone.progress
    cat /var/log/partclone.log >> $CLIENT_LOG
  done
}

function main()
{
  if [ "$isond" = "true" ]; then
    log " ** On Demand Enabled ** "
    for arg in "$taskArgs"; do case "$arg" in *=*) eval "$arg"; log "$arg"; esac; done
  else
    checkin
  fi

  if [ "$imageProtected" = "1" ]; then
    error "This Image Is Protected And Cannot Be Overwritten"
  fi

  mountSMB

  getHD

  if [ "$isond" != "true" ]; then
    log " ** Updating Client Status To In-Progress ** "
    `$curlAuth --data "computerId=$computer_id" "${web}UpdateStatusInProgress" $curlEndRedirect`
  fi

  log " ** Removing All Files For Existing Image: $image_name ** "
    `$curlAuth --data "profileId=$profile_id" "${web}DeleteImage" $curlEndRedirect`

  calcSize
  if [ "$upload_schema_only" = "true" ]; then
    checkout
  fi

  current_hd_number=0
  for hard_drive in $hard_drives; do
    current_hd_number=$(( $current_hd_number + 1 ))

    image_path=/storage/images/$image_name/hd$current_hd_number
    mkdir $image_path 2>> $CLIENT_LOG
	
    save_mbr_gpt
  
    get_partitions "true"
    
    uploadImage

  
    if [ "$lvmExists" = "true" ]; then
	  for partition in $partitions;
	    volume_group=$(pvs | grep $partition | awk '/^ / {print $2}')
		get_logical_volumes
		lvs_to_upload="$lvs_to_upload $logical_volumes "
	  done
      
	  partitions=$lvs_to_upload
      
      uploadImage "true"
      
    fi


  log " shrunk_volumes: $shrunk_volumes"
  for shrunk_volume in $shrunk_volumes; do
    filesystem_type=`blkid -po udev $shrunk_volume | grep FS_TYPE | awk -F'=' '{print $2}'`
    expandFS $shrunk_volume
  done

  if [ -n "$hostScripts" ]; then
    runScripts
  fi
  
checkout
}

main "$@"
  