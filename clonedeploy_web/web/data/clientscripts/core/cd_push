#!/bin/bash

. /bin/cd_global_functions

function process_hard_drives()
{
  local drive_name
  local lbs
  local drive_size_block
  
  get_hard_drives

  imaged_schema_drives=""
  current_hd_number=0
  for hard_drive in $hard_drives; do
    current_hd_number=$(( $current_hd_number + 1 ))
	
    drive_name=$(echo $hard_drive | cut -d "/" -f 3)
    lbs=$(cat /sys/block/$drive_name/queue/logical_block_size)
    drive_size_block=$(cat /sys/block/$drive_name/size)
    drive_size_bytes=$(expr $lbs '*' $drive_size_block)
	
    log "profileId=$profile_id&clientHdNumber=$current_hd_number&newHdSize=$drive_size_bytes&schemaHds=$imaged_schema_drives"
    hd_schema=$($curlAuth --data "profileId=$profile_id&clientHdNumber=$current_hd_number&newHdSize=$drive_size_bytes&schemaHds=$(remove_whitespace $imaged_schema_drives)" "${web}CheckHdRequirements" $curlEnd)
    log "$hd_schema"
	
    image_hd_to_use=$(( $(parse_json "$hd_schema" .SchemaHdNumber) + 1 ))
    image_path=/storage/images/$image_name/hd$image_hd_to_use
	
    create_partition_layout
	
    process_partitions
	
	#Only update BCD for mbr.  EFI BCD is based on GUID's which are restored to the partitions, keeping the BCD intact.
	if [ "$(parse_json "$hd_schema" .PartitionType)" = "mbr" ]; then
      update_bcd
	fi
	
    update_grub
	
    if [ "$(parse_json "$hd_schema" .PartitionType)" = "gpt" ]; then
	  log " ** Restoring GUID ** "
	  sgdisk $hard_drive -U$(parse_json "$hd_schema" .Guid) &>> $CLIENT_LOG	
	fi
	
    imaged_schema_drives="$imaged_schema_drives $(parse_json "$hd_schema" .SchemaHdNumber) "
done
}


function process_lvm()
{
  local array_index=-1
  local volume_group="$(parse_json "$current_partition" .VolumeGroup.Name)"
  local make_swap_result
  local current_logical_volume
  local volume_group
  local unescaped_lv_name
  
  while [  "$(( $array_index + 1 ))" -lt "$(parse_json "$current_partition" .VolumeGroup.LogicalVolumeCount)" ]; do
    array_index=$(( $array_index + 1))
    clear_and_move_down
    current_logical_volume="$(parse_json "$current_partition" .VolumeGroup.LogicalVolumes[$array_index])"
    unescaped_lv_name=$(echo $(parse_json "$current_logical_volume" .Name) | sed 's/--/-/g')
	
	if [ "$(parse_json "$current_logical_volume" .FileSystem)" = "swap" ]; then
      log "Creating Swap On $volume_group-$unescaped_lv_name"
      log "$(parse_json "$current_logical_volume" .Uuid)"
      mkswap /dev/mapper/$volume_group-$unescaped_lv_name -U $(parse_json "$current_logical_volume" .Uuid) &>> /tmp/makeswap
      cat /tmp/makeswap >>$CLIENT_LOG
      make_swap_result=$(cat /tmp/makeswap | grep "parsing UUID failed")
      if [ "$?" = "0" ]; then
        log " ...... Swap Creation Failed, Creating Swap With New UUID "
        mkswap /dev/mapper/$volume_group-$unescaped_lv_name &>> $CLIENT_LOG
      fi
      continue
    fi
				
    download_image "$current_logical_volume" "$volume_group-$unescaped_lv_name"
		
    clear
  done
}

function process_partitions()
{
  local partition_size_mb
  local array_index=-1
  while [  "$(( $array_index + 1 ))" -lt "$(parse_json "$hd_schema" .PhysicalPartitionCount)" ]; do
    array_index=$(( $array_index + 1))
    clear_and_move_down
    current_partition="$(parse_json "$hd_schema" .PhysicalPartitions[$array_index])"
    log "$current_partition"
		
    if [ -n "$(parse_json "$current_partition" .VolumeGroup)" ] && [ "$(parse_json "$current_partition" .VolumeGroup)" != "null" ]; then
      process_lvm
      continue
    fi
		
    if [ "$(parse_json "$current_partition" .FileSystem)" = "swap" ]; then
      log "Creating Swap On $hard_drive$(parse_json "$current_partition" .Number)"
      log "$(parse_json "$current_partition" .Uuid)"
      mkswap $hard_drive$(parse_json "$current_partition" .Number) -U $(parse_json "$current_partition" .Uuid) &>> $CLIENT_LOG	
      continue
    fi
			
    download_image "$current_partition" part
		
    partition_size_mb=$(parted -s $hard_drive unit MB print all | grep " $(parse_json "$current_partition" .Number) " -m 1 | awk -F' ' '{print $4}' | sed 's/MB//g')
    if [ "$partition_size_mb" -gt "2000" ]; then
      expand_volume ${hard_drive}$(parse_json "$current_partition" .Number) $(parse_json "$current_partition" .FileSystem)
	fi
		
    if [ "$(parse_json "$hd_schema" .PartitionType)" = "gpt" ]; then
      log " ** Restoring GUID ** "
      log " ...... part $part gptGUID: $gptGUID "
      sgdisk $hard_drive -u$(parse_json "$current_partition" .Number):$(parse_json "$current_partition" .Guid) &>> $CLIENT_LOG
    fi
		
    if [ "$(parse_json "$hd_schema" .BootPartition)" = "$(parse_json "$current_partition" .Number)" ] && [ "$(parse_json "$current_partition" .FileSystem)" = "ntfs" ]; then
      fix_ntfs_boot ${hard_drive}$(parse_json "$current_partition" .Number)
    fi
			
    change_computer_name
	
  done
}

function download_image()
{
  local current_object="$1"
  local file_name_prefix="$2"
  local destination
    
  if [ "$file_name_prefix" != "part" ]; then
    destination="/dev/mapper/$file_name_prefix"
  else
    destination=${hard_drive}$(parse_json "$current_object" .Number)
    file_name_prefix=part"$(parse_json "$current_object" .Number)"
  fi
  
  log " ** Starting Image Download For $destination ** " "display" 
  if [ -n "$computer_id" ]; then    
    null=$($curlAuth --data "computerId=$computer_id&partition=$destination" "${web}UpdateProgressPartition" $curlEnd)
  fi
  sleep 7
  echo
	
  if [ "$(parse_json "$current_object" .Compression)" = "gz" ]; then
    partCompAlg="/usr/bin/gzip -c -d"
    partCompExt="gz"
  elif [ "$(parse_json "$current_object" .Compression)" = "lz4" ]; then
    partCompAlg="lz4 -d"
    partCompExt="lz4"
  else
    error "Could Not Determine Compression Algorithm For Partition"
  fi
		
  touch /tmp/clone.progress
			
  if [ "$multicast" = "true" ]; then
    log "cd_reporter $computer_id partclone & udp-receiver --portbase $portBase --no-progress --mcast-rdv-address $serverIP $clientReceiverArgs | partclone.$(parse_json "$current_partition" .PartcloneFileSystem) -B -r -o $hard_drive$(parse_json "$current_partition" .Number)"
    cd_reporter $computer_id partclone & udp-receiver --portbase $portBase --no-progress --mcast-rdv-address $serverIP $clientReceiverArgs | partclone.$(parse_json "$current_partition" .PartcloneFileSystem) -B -r -o $hard_drive$(parse_json "$current_partition" .Number)
  else
    log "cd_reporter $computer_id partclone & $partCompAlg $image_path/$file_name_prefix.$(parse_json "$current_object" .PartcloneFileSystem).$partCompExt | partclone.$(parse_json "$current_object" .PartcloneFileSystem) -B -r -o $destination"
    cd_reporter $computer_id partclone & $partCompAlg $image_path/$file_name_prefix.$(parse_json "$current_object" .PartcloneFileSystem).$partCompExt | partclone.$(parse_json "$current_object" .PartcloneFileSystem) -B -r -o $destination
  fi
			
  rm /tmp/clone.progress
  cat /var/log/partclone.log >> $CLIENT_LOG
}

function restore_mbr_gpt()
{
  local gpt_status
  local hybrid_status
  
  log " ** Restoring MBR / GPT On $hard_drive ** " "display"
  dd if=$image_path/table of=$hard_drive &>>$CLIENT_LOG				
		
  #Sometimes restoring results in damaged GPT.
  gpt_status=$(gdisk -l $hard_drive <<< "2" 2>>$CLIENT_LOG | grep 'GPT:' | awk '{$1=""; print $0}' | sed 's/^ //')
  if [ "$gpt_status" = "damaged" ]; then
    gdisk $hard_drive << eof >> $CLIENT_LOG
2
w
y
eof
  fi
	
  hybrid_status=$(gdisk -l $hard_drive <<< "q" 2>> $CLIENT_LOG| grep 'MBR:' | awk '{$1=""; print $0}' | sed 's/^ //')
  if [ "$hybrid_status" = "hybrid" ]; then
    gpt_is_hybrid="true"
  fi
	
  log " ...... Complete" "display"
  echo 
  partprobe &>/dev/null
  sleep 2
}

function update_grub()
{

	log " ** Checking If Grub Is Required ** "
	dd if=$hard_drive of=/tmp/grubcheck bs=512 count=1 2> /dev/null
	strings /tmp/grubcheck | grep -i "grub"
	if [ "$?" = "0" ]; then
		log " ...... Grub Is Required, Searching For Boot Files "
		if [ -n "$grubRoot" ]; then
			log " ...... Grub Root Overridden By User $grubRoot "
			grubHD=$(echo $grubRoot | cut -d"," -f1)
			grubHD="$grubHD)"
		else
			grub --batch <<eof>> /tmp/grubroot
find /grub/menu.lst
find /boot/grub/menu.lst
eof
			cat /tmp/grubroot >>$CLIENT_LOG
			grubHdPass=$(( $current_hd_number - 1 ))
			grubRoot=$(cat /tmp/grubroot | grep -i "$hard_drive$grubHdPass")
			grubHD=$(echo $grubRoot | cut -d"," -f1)
			grubHD="$grubHD)"
		fi
			log "grubHdPass: $grubHdPass grubRoot: $grubRoot grubHD: $grubHD current_hd_number: $current_hd_number"
		
		if [ -n "$grubRoot" ]; then
			log " ...... Found Legacy Grub On $grubRoot "
			log " ...... Restoring Grub Legacy "
			grub --batch <<eof>> $CLIENT_LOG
root $grubRoot
setup $grubHD
eof
		else
			log " ...... Could Not Find Boot Files For Grub Legacy.  This Is Normal If Grub2 Is Being Used."
			log " Otherwise, You Need To Manually Set Grub Root Using The Host Argument grubRoot="
		fi
	else
		log " ...... Grub Is Not Required"
	fi
}


function create_partition_layout()
{
  local layout_created_successfully
  local layout_failed_counter
  local gpt_partition_count
  local mbr_partition_count
  local preexisting_volume_groups
  local preexisting_physical_volumes
  local new_volume_groups
  local new_logical_volumes
  local volume_group_uuid
  local logical_volume_uuid
  
  if [ "$(parse_json "$hd_schema" .IsValid)" = "true" ]; then
    log " ...... HD Meets The Minimum Sized Required"		
  elif [ "$(parse_json "$hd_schema" .IsValid)" = "false" ]; then
    log " ...... $(parse_json "$hd_schema" .Message)" "display"
    sleep 10
    continue		
  elif [ "$(parse_json "$hd_schema" .IsValid)" = "original" ]; then
    log " ...... HD Matches Original Size Of Image, Dynamic Partition Layout Will Not Be Used"
  else
    error "Unknown Error Occurred While Determining Minimum HD Size Required.  Check The Exception Log"
  fi
	
  erase_mbr_gpt
  restore_mbr_gpt
		
  if [ "$(parse_json "$hd_schema" .IsValid)" = "true" ] || [ "$force_dynamic_partitions" = "true" ] || [ "$partition_method" = "script" ] || [ "$partition_method" = "layout" ]; then
    log " ** Creating Partition Table On $hard_drive ** " "display"
    $curlAuth --data "imageProfileId=$profile_id&hdToGet=$image_hd_to_use&newHDSize=$drive_size_bytes&clientHD=$hard_drive&taskType=deploy" "${web}GetPartLayout" $curlEnd | dos2unix > /tmp/newPartLayout
    cat /tmp/newPartLayout >> $CLIENT_LOG
		
    layout_failed_counter=0
    if [ "$(parse_json "$hd_schema" .PartitionType)" = "gpt" ]; then
      while [ "$layout_created_successfully" != "true" ]; do		
        delete_all_partitions $hard_drive
        bash /tmp/newPartLayout
        partprobe &>/dev/null
        gpt_partition_count=$(gdisk -l $hard_drive 2> /dev/null| awk '/^ / {print $1}' | grep -vi mbr | grep -vi gpt | grep -vi bsd | grep -vi apm -c)
        if [ "$gpt_partition_count" = "$(parse_json "$hd_schema" .PhysicalPartitionCount)" ]; then
          layout_created_successfully="true"
          log " ...... Success" "display"
        else
          layout_failed_counter=$(( $partCreatedCounter + 1 ))
          log " ...... Could Not Create Partition Layout.  Retrying Attempt $layout_failed_counter"
          if [ "$layout_failed_counter" -gt "10" ]; then
            error "Could Not Create Partition Layout"
          fi
        fi
      done
    else
      delete_all_partitions $hard_drive
      bash /tmp/newPartLayout
      partprobe &>/dev/null
      mbr_partition_count=$(fdisk -l 2>/dev/null | grep $hard_drive | grep -v ${hard_drive}: -c)
      if [ "$mbr_partition_count" != "$(parse_json "$hd_schema" .PhysicalPartitionCount)" ]; then
        error "Could Not Create Partition Layout"
      fi
    fi
  fi
	
  log " ** New Partition Table Is ** "
  if [ "$(parse_json "$hd_schema" .PartitionType)" = "gpt" ]; then
    gdisk -l $hard_drive &>>$CLIENT_LOG
  else
    fdisk -l &>>$CLIENT_LOG
  fi
	
  if [ "$gpt_is_hybrid" = "true" ]; then
    create_hybrid_gpt
  fi
	
  if [ "$(parse_json "$hd_schema" .UsesLvm)" = "true" ]; then
    if [ "$(parse_json "$hd_schema" .IsValid)" = "original" ]; then
      log "Creating Original LVM"
      $curlAuth --data "profileId=$profile_id&clientHd=$hard_drive&hdToGet=$image_hd_to_use" "${web}GetOriginalLvm" $curlEnd | dos2unix > /tmp/lvmcommands
      cat /tmp/lvmcommands >> $CLIENT_LOG
    fi
	
    if [ -s "/tmp/lvmcommands" ]; then
      dmsetup remove_all
      preexisting_volume_groups=$(vgs --noheadings | awk '/^ / {print $1}')
      for vg in $preexisting_volume_groups; do
        vgremove $vg -fy
      done
	
      preexisting_physical_volumes=$(pvs --noheadings | grep $hard_drive | awk '/^ / {print $1}')
      for pv in $preexisting_physical_volumes; do
        pvremove $pv -fy
      done
	
      bash /tmp/lvmcommands &>>$CLIENT_LOG
      vgscan
		
      new_volume_groups=$(vgs --noheadings | awk '/^ / {print $1}')
      for vg in $new_volume_groups; do
        new_logical_volumes=$(lvs | grep "$vg" | awk '/^ / {print $1}')
        volume_group_uuid=$(vgs -v  2>/dev/null | grep "$vg" | awk '/^ / {print $9}')
        sed -i "s/$volume_group_uuid/$(cat /tmp/vg-$vg)/g" /tmp/lvm-$vg 
        for logical_volume in $new_logical_volumes; do		
          logical_volume_uuid=$(lvs -v 2>/dev/null | grep "$vg" | grep "$logical_volume" | awk '/^ / {print $10}')
          sed -i "s/$logical_volume_uuid/$(cat /tmp/$vg-$logical_volume)/g" /tmp/lvm-$vg 
        done
        vgcfgrestore $vg -f /tmp/lvm-$vg
      done			
    else
      return 0
    fi
  fi
}

function create_hybrid_gpt()
{
  #Fix Me. Very generic way of creating hybrid.  May not work in many situations.
  gdisk $hard_drive << eof >> $CLIENT_LOG
r
h
2 3 4 5 6 7 8 9 10
y

n

n

n

n

w
y
eof

  fdisk $hard_drive << eof >> $CLIENT_LOG
x
M
r
a
$(parse_json "$hd_schema" .BootPartition)
w
q
eof
}

function process_scripts()
{
	
	mkdir /scripts
	log " ** Running Script(s) ** " "display"
	sleep 1
	cd /scripts
	arr=$(echo "$hostScripts" | tr "," "\n");
	for script in $arr; do
	
		curl -sSk -H "Authorization: "$(echo -n "$WDS_KEY" | base64)"" -FscriptName="$script" "${web}DownloadCustomScripts" -o /scripts/"$script" --connect-timeout 10 --stderr - >> $CLIENT_LOG
		log " ...... Running $script" "display"
		sleep 1
		chmod +x "$script"
		./$script "$hard_drive" "$taskArgs"
		sleep 1
		echo
	done
}



function update_bcd()
{
  #Fix Me.  Function is run once against each hard drive.  If hard drive is dual boot of multiple version of Windows, this will fail.
  local windows_partition
  local windows_partition_offset
  local bcd_partition
  local original_bcd
  local updated_bcd
  
  if [ "$skip_fix_bcd" = "true" ]; then
    log "BCD Update Has Been Skipped Via Image Profile"
    return 0
  fi

  local array_index=-1
  while [  "$(( $array_index + 1 ))" -lt "$(parse_json "$hd_schema" .PhysicalPartitionCount)" ]; do
    array_index=$(( $array_index + 1))
    clear_and_move_down
    current_partition="$(parse_json "$hd_schema" .PhysicalPartitions[$array_index])"
    if [ "$(parse_json "$current_partition" .FileSystem)" != "ntfs" ]; then
      continue
    fi

    log " ** Updating BCD ** " "display"
    mkdir /mnt/ntfs
    ntfs-3g -o force,rw,remove_hiberfile ${hard_drive}$(parse_json "$current_partition" .Number) /mnt/ntfs 2> /dev/null
    if [ -f "/mnt/ntfs/Windows/System32/winload.exe" ] || [ -f "/mnt/ntfs/Windows/system32/winload.exe" ]; then
      log " ...... Found Windows Partition On ${hard_drive}$(parse_json "$current_partition" .Number)" "display"
      windows_partition=${hard_drive}$(parse_json "$current_partition" .Number)	
      windows_partition_offset=$(parted -s $hard_drive unit b print all | grep " $(parse_json "$current_partition" .Number) " -m 1 | awk -F' ' '{print $2}' | sed 's/B//g')			
    fi
		
    if [ -f "/mnt/ntfs/Boot/BCD" ]; then
      log " ...... Found BCD Partition On${hard_drive}$(parse_json "$current_partition" .Number)" "display"
      bcd_partition=${hard_drive}$(parse_json "$current_partition" .Number)
      reged -x /mnt/ntfs/Boot/BCD . Objects /tmp/regbcd >> /dev/null
      original_bcd=$(cat /tmp/regbcd)
    fi
    umount /mnt/ntfs
  done
  
   if [ -n "$windows_partition" ] && [ -n "$bcd_partition" ]; then
    updated_bcd=$($curlAuth -F bcd="$(echo -n "$original_bcd" | base64)" -F offsetBytes="$(echo -n "$windows_partition_offset" | base64)" "${web}UpdateBcd" $curlEnd)
    echo $updated_bcd | base64 -d >>/tmp/updatedbcd
    log " ** Updated BCD Is ** "
    cat /tmp/updatedbcd >> $CLIENT_LOG	
    ntfs-3g -o force,rw,remove_hiberfile $bcd_partition /mnt/ntfs 2> /dev/null
    reged -I -C /mnt/ntfs/Boot/BCD . /tmp/updatedbcd >> $CLIENT_LOG
    umount /mnt/ntfs
    log " ...... Success" "display"
  else
    log " ...... Could Not Verify Windows Partition Or BCD Partition.  BCD Has Not Been Changed" "display"
    log " ...... windows_partition: $windows_partition bcd_partition: $bcd_partition" 
  fi	
}

function fix_ntfs_boot()
{
  local partition=$1
  log " ** Fixing NTFS Geometry ** " "display"
  partclone.ntfsfixboot -p $partition >> $CLIENT_LOG
  partclone.ntfsfixboot -w $partition >> $CLIENT_LOG
		
}

function erase_mbr_gpt()
{
  log " ** Clearing MBR / GPT ** "
  sgdisk -Z $hard_drive &>>$CLIENT_LOG
  dd if=/dev/zero of=$hard_drive bs=512 count=2047 &>>$CLIENT_LOG
  partprobe &> /dev/null
}

function delete_all_partitions()
{
	#Delete all partitions but keep boot record intact
	log " ** Deleting Existing Partitions ** "
	if [ "$(parse_json "$hd_schema" .PartitionType)" = "gpt" ]; then
	gptPartCount=$(gdisk -l $1 2> /dev/null| awk '/^ / {print $1}' | grep -vi mbr | grep -vi gpt | grep -vi bsd | grep -vi apm -c)
	deleteCounter=0
		while [ "$gptPartCount" -gt "0" ]; do
			deleteCounter=$(( $deleteCounter + 1 ))
			echo "gdisk $1 &>/dev/null <<GDISK" > /tmp/partitionDelete
			for part_num in $(gdisk -l $1 2> /dev/null | awk '/^ / {print $1}' | grep -vi mbr | grep -vi gpt | grep -vi bsd | grep -vi apm); do			
				echo d >> /tmp/partitionDelete
				echo "$part_num" >> /tmp/partitionDelete
			done
			
			echo w >> /tmp/partitionDelete
			echo y >> /tmp/partitionDelete
			echo y >> /tmp/partitionDelete
			echo q >> /tmp/partitionDelete
			echo GDISK >> /tmp/partitionDelete
			cat /tmp/partitionDelete >> $CLIENT_LOG
			bash /tmp/partitionDelete
			
			gdisk $1 &>/dev/null <<GDISK
d
$part_num
w
y
y
q
GDISK
			gptPartCount=$(gdisk -l $1 2> /dev/null | awk '/^ / {print $1}' | grep -vi mbr | grep -vi gpt | grep -vi bsd | grep -vi apm -c)
			if [ "$deleteCounter" -gt "1000" ]; then
				log " ...... Partitions Still Exist"
				gdisk -l $1 &>>$CLIENT_LOG
				error "Could Not Delete GPT Partitions"
				
			fi
		done		
	else
		mbrPartCount=$(fdisk -l 2>/dev/null | grep $hard_drive | grep -v ${hard_drive}: -c)
		log "$mbrPartCount"
		deleteCounter=0
		while [ "$mbrPartCount" -gt "0" ]; do
			deleteCounter=$(( $deleteCounter + 1 ))
			fdisk $1 &>/dev/null <<FDISK
d


w
FDISK
			mbrPartCount=$(fdisk -l 2>/dev/null | grep $hard_drive | grep -v ${hard_drive}: -c)
			if [ "$deleteCounter" -gt "1000" ]; then
				log " ...... Partitions Still Exist"
				fdisk -l &>>$CLIENT_LOG
				error "Could Not Delete MBR Partitions"			
			fi
		done
	fi
}

function change_computer_name()
{
	local partition=$1
	if [ -n "$hostName" ]; then
		mkdir -p /win
		
		
			if [ "$fsType" = "ntfs" ]; then
				log " ** Changing Host Name On $partition ** " "display"
				sleep 1
		
				ntfs-3g -o force,rw,remove_hiberfile $hard_drive$x /win &>/dev/null
				if [ "$?" = "0" ]; then
					#Win 8
					if [ -f "/win/Windows/System32/Sysprep/unattend.xml" ]; then
						log " ...... Found Answer File, Changing Host Name" "display"
						rm /win/Windows/System32/Sysprep/unattend.xml
						cd /win/Windows/Panther
						cat unattend.xml | sed -e s/CrucibleWDS/$hostName/ > unattend.tmp
						mv unattend.tmp unattend.xml
					#Win 7 and Vista
					elif [ -f "/win/Windows/System32/sysprep/unattend.xml" ]; then
						log " ...... Found Answer File, Changing Host Name" "display"
						rm /win/Windows/System32/sysprep/unattend.xml
						cd /win/Windows/Panther
						cat unattend.xml | sed -e s/CrucibleWDS/$hostName/ > unattend.tmp
						mv unattend.tmp unattend.xml
					#Win XP
					elif [ -f "/win/Sysprep/sysprep.inf" ]; then
						log " ...... Found Answer File, Changing Host Name" "display"
						cd /win/Sysprep
						cat sysprep.inf | sed -e s/CrucibleWDS/$hostName/ > sysprep.tmp
						mv sysprep.tmp sysprep.inf
					else
						log " ...... Could Not Find Answer File, Attempting Registry Change" "display"
						root="/win/Windows/System32/config/SYSTEM"
						hnkey1="\ControlSet001\Services\Tcpip\Parameters\NV Hostname"
						hnkey2="\ControlSet001\Control\ComputerName\ComputerName\ComputerName"
						update_registry_key
					
						hnkey1="\ControlSet001\Services\Tcpip\Parameters\Hostname"
						hnkey1="\ControlSet001\Services\Tcpip\Parameters\HostName"
						update_registry_key
						
						hnkey1="\ControlSet001\Services\Tcpip\Parameters\NV HostName"
						hnkey2="\ControlSet001\Control\ComputerName\ComputerName\ComputerName"
						update_registry_key		

						root="/win/Windows/System32/config/SYSTEM"
						hnkey1="\ControlSet001\services\Tcpip\Parameters\NV Hostname"
						hnkey2="\ControlSet001\Control\ComputerName\ComputerName\ComputerName"
						update_registry_key		

						root="/win/Windows/System32/config/SYSTEM"
						hnkey1="\ControlSet001\services\Tcpip\Parameters\NV Hostname"
						hnkey2="\ControlSet001\Control\ComputerName\ComputerName\ComputerName"
						update_registry_key		

						root="/win/WINDOWS/system32/config/system"
						hnkey1="\ControlSet001\Services\Tcpip\Parameters\NV Hostname"
						hnkey2="\ControlSet001\Control\ComputerName\ComputerName\ComputerName"
						update_registry_key
					fi
					echo
					cd /
					umount /win	
				fi
			fi
		
	else
		log " ...... Could Not Determine The Host Name Of This Machine.  Host Name Has Not Been Changed."
	fi
}

function update_registry_key()
{
	reged -e "$root" &>/dev/null  <<EOFN 
ed $hnkey1
$hostName
ed $hnkey2
$hostName
q
y
EOFN

}

function main()
{

  log_boot_args

  if [ "$is_ondemand" = "true" ]; then
    log " ** Using On Demand Mode ** "
	for arg in "$ondemand_arguments"; do case "$arg" in *=*) eval "$arg"; log "$arg"; esac; done
  else
    checkin
	if [ "$multicast" = "true" ]; then
	  $curlAuth --data "computerId=$computer_id" "${web}UpdateStatusInProgress" $curlEnd
	else
	  log " ** Checking Current Queue ** " "display"	
      while true; do
	    queue_status=$($curlAuth --data "computerId=$computer_id" "${web}CheckQueue" $curlEnd)
		if [ "$(parse_json "$queue_status" .Result)" = "true" ]; then
		  break
		else
		  echo "** Queue Is Full, Waiting For Open Slot ** "
		  echo " ...... Current Position $(parse_json "$queue_status" .Position)"
		  sleep 5
		fi
      done
	fi	  		
  fi

  sleep 2

  mount_smb

  process_hard_drives

  if [ -n "$hostScripts" ]; then
		process_scripts
  fi
	
  checkout
}

is_ondemand="$1"
ondemand_arguments="$2"
main "$@"

