#!/bin/sh

. functions

isond="$1"
taskArgs="$2"
logBootArgs

if [ "$isond" = "true" ]; then
	log " ** Using On Demand Mode ** "
	for arg in "$taskArgs"; do case "$arg" in *=*) eval "$arg"; log "$arg"; esac; done
else
	checkin
fi

if [ "$imageProtected" = "1" ]; then
	error "This Image Is Protected And Cannot Be Overwritten"
fi


mountSMB


getHD
echo
sleep 2

if [ "$isond" != "true" ]; then
	log " ** Updating Client Status To Active ** "
	curl -sSk -H "Authorization: "$(echo -n "$WDS_KEY" | base64)"" -Fmac="$(echo -n $mac | base64)" "${web}InSlot" --connect-timeout 10 --stderr - >> /tmp/clientlog.log
fi

log " ** Removing All Files For Existing Image: $imgName ** "
delImageStat=`curl -sSk -H "Authorization: "$(echo -n "$WDS_KEY" | base64)"" -FimgName="$(echo -n $imgName | base64)" "${web}DeleteImage" --connect-timeout 10 --stderr -`
if [ "$delImageStat" != "true" ]; then
	error "Could Not Clear Image Directory. $delImageStat"
fi


calcSize


hdPass=0
for hd in $disks; do
	hdPass=$(( $hdPass + 1 ))

	imgPath=$imgName/hd$hdPass
	
		
	log " ** Checking For Partition Table Types Before Upload ** "
	upGPT=`gdisk -l $hd <<< "q" 2>> /tmp/clientlog.log | grep 'GPT:' | awk '{$1=""; print $0}' | sed 's/^ //'`
	if [ "$upGPT" = "present" ]; then
		usingGPT=true
		upMBR=`gdisk -l $hd <<< "q" 2>> /tmp/clientlog.log | grep 'MBR:' | awk '{$1=""; print $0}' | sed 's/^ //'`
		if [ "$upMBR" = "MBR only" ]; then
			error "This Hard Drive Appears To Have Both GPT And MBR.  CrucibleWDS Does Not Know What To Use.  You Must First Convert The Drive To One Or The Other Before Uploading"
		fi
	elif [ "$upGPT" = "damaged" ]; then
		error "The GPT Table Is Damaged And Cannot Be Saved.  You Must Fix This Before Uploading This Image"
	fi
	log " ...... upGPT: $upGPT upMBR: $upMBR" 
	
	
	log " ** Determining Partition Count ** " "display" 
	#Manually specifying partitions is only valid for the first hd
	if [ "$hdPass" = "1" ]; then
		if [ -n "$parts" ]; then
			log " ...... Partitions Overridden By User, User Specified $parts" "display"
		else
			parts=$(partinfo --parts $hd 2>> /tmp/clientlog.log)
		fi
	else
		parts=$(partinfo --parts $hd 2>> /tmp/clientlog.log)
	fi
	
	partCount=0	
	for part in $parts; do
		partCount=$(( $partCount + 1 ))
	done
	
	sleep 2
	
	if [ "$partCount" = "0" ]; then
		error "Unable To Determine Partition Count Or There Are No Partitions On This Drive"
	fi	
	log " ...... Found $partCount Partition(s)" "display"
	echo
		
		
	mkdir $imgPath
	
	
	log " ** Saving MBR / GPT ** " "display"	

	if [ "$usingGPT" = "true" ]; then
		checkPartStart=$(gdisk $hd -l | awk '/^ / {print $2+0}' | grep -vw "0" | sort -n | head -n1)
	else
		checkPartStart=$(parted -s $hd unit s print all | awk -F' ' '{print $2+0}' | grep -vw "0" | sort -n | head -n1)
	fi

	toSave=$(( $checkPartStart - 1 ))
		
	log " ...... drive: $drive checkPartStart: $checkPartStart toSave: $toSave "
		
	
		dd if=$hd of=/images/$imgPath/table count=$toSave bs=512 &>> /tmp/clientlog.log 
		if [ -s "/images/$imgPath/table" ]; then
			log " ...... Success" "display"
		else
			error "Could Not Save MBR /GPT .  Check Permissions."
		fi
	
	echo
	sleep 5
	
	for part in $parts; do
		local fsType=`blkid -po udev $part | grep FS_TYPE | awk -F'=' '{print $2}'`
		if [ "$fsType" = "ntfs" ]; then
			ntfs-3g -o force,rw $part /mnt/ntfs 2> /dev/null				
				if [ -f "/mnt/ntfs/Boot/BCD" ]; then
					log " ** Original BCD ** "
					reged -x /mnt/ntfs/Boot/BCD . Objects /tmp/regbcd >>/dev/null
					cat /tmp/regbcd >> /tmp/clientlog.log
	
					
						cp /mnt/ntfs/Boot/BCD /images/$imgPath/BCD
						cp /mnt/ntfs/bootmgr /images/$imgPath/bootmgr
						
				fi
			umount /mnt/ntfs
		fi
	done
	
	pullGlobal
	
	if [ "$lvmExists" = "true" ]; then
		pullLVM
	fi
	
	if [ -n "$hostScripts" ]; then
	runScripts
	fi

done

checkout

	