#!/bin/bash
CLIENT_LOG="/tmp/clientlog.log"

function set_curl_command()
{
	export curlCommand="curl -sSk"
	export curlEnd=" --connect-timeout 10 --stderr -"
	export curlEndRedirect=" --connect-timeout 10 --stderr - >> /tmp/clientlog.log"
}

function set_curl_auth()
{
	export curlAuth="curl -sSk -H Authorization:$(echo -n "$USER_TOKEN" | base64)"
}

function clear_and_move_down()
{
	clear
	local line=0
	while [ "$line" -le "6" ]; do
		line=$(( $line + 1 ))
		echo
	done
}

function parse_json()
{
	echo `echo "$1" | jq "$2" -r`
}

function remove_whitespace() {
    local var="$*"
    var="${var#"${var%%[![:space:]]*}"}"   # remove leading whitespace characters
    var="${var%"${var##*[![:space:]]}"}"   # remove trailing whitespace characters
    echo -n "$var"
}

function checkin()
{	
	log " ** Looking For Active Task ** " "display"
	checkInStatus=`$curlAuth --data "computerMac=$mac" "${web}CheckIn" $curlEnd`
	if [ ! "$?" = "0" ]; then
		error "$checkInStatus"
	else
		if [ "`parse_json "$checkInStatus" .Result`" != "true" ]; then
			error "`parse_json "$checkInStatus" .Message`"
		else
			sleep 1
			for arg in "`parse_json "$checkInStatus" .TaskArguments`"; do case "$arg" in *=*) eval "$arg"; log "$arg"; esac; done
			log " ...... Success" "display"
		fi
	fi
	
	echo
	sleep 2
}

function checkout()
{
	echo
	log " ** Closing Active Task ** " "display"
	cd /
	sleep 10
	umount /storage &> /dev/null
	sleep 2
	if [ "$multicast" = "true" ]; then
	mccheckoutResult=`curl -H "Authorization: "$(echo -n "$WDS_KEY" | base64)"" -sSk -FportBase="$(echo -n $portBase | base64)" "${web}McCheckOut" --connect-timeout 10 --stderr -`
		log " ...... $mccheckoutResult"
	fi
	
	cat /tmp/clientlog.log | grep -v "percent completed" > /tmp/cleanedlog.log
	if [ "$is_ondemand" = "true" ]; then
	  log_status=$($curlAuth -F computerId="$(echo -n $computer_id | base64)" -F logContents="$(cat /tmp/cleanedlog.log | base64)"  -F subType="$(echo -n $task | base64)" "${web}UploadLog" $curlEnd)
	fi
	checkout_status=`$curlAuth --data "computerMac=$mac" "${web}CheckOut" $curlEnd`
	log " ...... $checkout_status" "display"
		
	$curlAuth -F computerId="$(echo -n $computer_id | base64)" -F logContents="$(cat /tmp/cleanedlog.log | base64)"  -F subType="$(echo -n $task | base64)" "${web}UploadLog" $curlEnd
			
	echo
		
		
	sleep 1;
	
	if [ "$task_completed_action" = "Power Off" ]; then
		poweroff;
	elif [ "$task_completed_action" = "Exit To Shell" ]; then
		/bin/bash
	else
		reboot -f
	fi
	
}




function error()
{
	echo
	log " ** An Error Has Occurred ** " "display"
	log " ...... $1" "display"
	echo
	echo " ** Rebooting In One Minute ** "
	
	if [ -z "$computer_id"  ]; then
			computer_id="-1"
	fi
		
	
	cat /tmp/clientlog.log | grep -v "percent completed" > /tmp/cleanedlog.log
	$curlAuth -F computerId="$(echo -n $computer_id | base64)" -F logContents="$(cat /tmp/cleanedlog.log | base64)"  -F subType="$(echo -n $task | base64)"  -F mac="$(echo -n $mac | base64)" "${web}UploadLog" $curlEnd
	sleep 60
	if [ "$task_completed_action" = "Power Off" ]; then
		poweroff;
	elif [ "$task_completed_action" = "Exit To Shell" ]; then
		/bin/bash;
	else
		reboot -f
	fi 
}

function expand_volume()
{

	local partition="$1"
	local filesystem="$2"
	
	if [ "$filesystem" = "ext2" ] || [ "$filesystem" = "ext3" ] || [ "$filesystem" = "ext4" ]; then
		log " ** Expanding EXT Volume On $1 ** " "display"
		partprobe &>/dev/null;
		sleep 5

		resize2fs $1 &>/dev/null
		
		if [ ! "$?" = "0" ]; then
			log "Warning, EXT File System Did Not Resize Properly.  Check Your Disk Size After Booting" "display"
		else
			log " ...... Success" "display"
		fi
		echo
		e2fsck -fp $1 &>/dev/null
	
	elif [ "$filesystem" = "ntfs" ]; then
	  ntfsfix -b -d $1 &>>/tmp/clientlog.log
		volumeSize=`ntfsresize -f -i -P $1 | grep -i "current volume size:" | cut -d " " -f4`
		deviceSize=`ntfsresize -f -i -P $1 | grep -i "current device size:" | cut -d " " -f4`
		volumeMargin=$(( $deviceSize - $volumeSize ))
		log " volumeMargin: $volumeMargin"
		if [ "$volumeMargin" -lt "104857600" ]; then
			return 0
		fi
		log " ** Expanding NTFS Volume on $1 ** " "display"

		partprobe &>/dev/null;
		sleep 5
			
		#Found That expanding all the way sometimes corrupted the filesystem
		deviceSize=$(( $deviceSize - 10485760 )) #Don't expand too far
		log "Expanding NTFS Volume To: $deviceSize"
		ntfsresize -f -b -s $deviceSize $1 &>> /tmp/clientlog.log << CONFIRM
y
CONFIRM

		if [ ! "$?" = "0" ]; then
			log "Warning, NTFS File System Did Not Resize Properly.  Check Your Disk Size After Booting To Windows" "display"
		else
			log " ...... Success" "display"
		fi
	
		echo 
		ntfsfix -b -d $1 &>>/tmp/clientlog.log
	fi

}

function get_hard_drives()
{
	log " ** Looking For Hard Drive(s) ** " "display"
	log " ...... Displaying Available Devices "
	blockdev --report &>> /tmp/clientlog.log
	fdisk -l &>> /tmp/clientlog.log
	
	if [ -n "$custom_hard_drives" ]; then
		hard_drives="$custom_hard_drives"
		log " ...... Hard Drive(s) Set By Image Profile: $hard_drives" "display"		
	else
		hard_drives=`lsblk -ipdno KNAME`	
	fi
	
	hard_drive_count=0
	for hdd in $hard_drives; do	
		hard_drive_count=$(( $hard_drive_count + 1 ))
	done
		
	log " ...... Found $hdCount Drive(s)" "display"
	log " ...... Drive(s): $hard_drives" "display"
	
	if [ "$hard_drive_count" = "0" ]; then
		error "Could Not Find A Hard Drive Attached To This Computer.  Try A Different Kernel."
	fi
	sleep 2
}

function log()
{
	echo "" >> /tmp/clientlog.log
	if [ "$2" = "display" ]; then
		echo "$1" | tee -a /tmp/clientlog.log
	else
		echo "$1" >> /tmp/clientlog.log
	fi
}

function log_boot_args()
{
	log " ** Displaying Boot Arguments ** "
	log "$(cat /proc/cmdline) MAC: $mac"
	uname -a >> /tmp/clientlog.log
}


function mount_smb()
{
	log " ** Mounting SMB Share **" "display"
	mkdir /storage &>> /tmp/clientlog.log
	smbInfo=$($curlAuth --data "dpId=$dp_id" "${web}DistributionPoint" $curlEnd)
	for smbVersion in 3.0 2.1 2.0 1.0; do	
		mount -t cifs "$(parse_json "$smbInfo" .SharePath)" /storage -o user="$(parse_json "$smbInfo" .Username)",pass="$(parse_json "$smbInfo" .Password)",dom="$(parse_json "$smbInfo" .Domain)",vers=$smbVersion 2>/tmp/mntstat
		if [ ! $? = "0" ]; then
			cat /tmp/mntstat >> /tmp/clientlog.log
			errormsg=$(cat /tmp/mntstat)
			
		else
			log " ...... Success" "display"

			cd /storage/images/$imgName;
			if [ ! $? = "0" ]; then
				error "Could Not Change Directory To /images/$imgName Check Permissions"
			fi
			break
		fi
		if [ "$smbVersion" = "1.0" ]; then
			error "SMB 1.0 Is Not Supported"
		fi
	done
	echo
	sleep 2
}



